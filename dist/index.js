/******/ (() => { // webpackBootstrap
var __webpack_exports__ = {};
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/// class method FantasyMap that inclued all methods for the completion of the application
var FantasyMap = /*#__PURE__*/function () {
  // relative constructor class
  function FantasyMap() {
    _classCallCheck(this, FantasyMap);
    //this.map is in charge of setting up the basic map. 
    this.map = null;
    //this.locations is in charge of setting up the locations found in the map, found by connecting to the URL from the locations.JSON FILE
    this.locations = [];
    //this.markers is in charge of setting up the toggle Markers of the applications. 
    this.markers = [];
    //this is is charge of making sure that the markers are visible by defualt when the map starts. 
    this.bridgeMarkerVisible = true;
    //this activates the initializeMap method
    this.initializeMap();
    //this activates the fetchLocationsData that draws from the locations.json data.
    this.fetchLocationsData();
    //this is for creating the donutChart that will use chart.js to get the species data from the locations.json
    this.createDonutChart();
    //this is for creating the classes chart that will use chart.js to get the classes data from the locations.

    this.createClassesChart();
    // this.createFaction();  - wanted to implement a third graph displaying the factions, but could not impliment with given time
  }

  //initializeMap method is in charge of getting the base map information
  _createClass(FantasyMap, [{
    key: "initializeMap",
    value: function initializeMap() {
      var _this = this;
      //set up the map connection
      if (!this.map) {
        // set up its starting zoom level, taken from leaflet.js configuration
        var initialZoom = 10.9;
        //set up the map's canvas 
        this.map = L.map('map', {
          renderer: L.canvas(),
          //set its minzoom level to the exact same zoom level as its starting intialZoom
          minZoom: initialZoom,
          //set max zoom to 18
          maxZoom: 18
        }).setView([0, 0], initialZoom);
        //connect the imageUrl to the map file as its background
        var imageUrl = './assets/siruksvalleymap.png';
        // set its bound's, so to avoid a terrible white screen outside the map size
        var bounds = [[-1, -1], [1, 1]];
        //take the imageUrl and its defined bounds and add it to the this.map found above in a leaflet image overlay
        L.imageOverlay(imageUrl, bounds).addTo(this.map);
        //with the map set is maxbounds to the parameter of bounds defined above.
        this.map.setMaxBounds(bounds);
        //set its viscosity
        this.map.options.maxBoundsViscosity = 1.0;
        //set a additional zoom buttons on the left top side of the map
        this.map.on('zoomend', function () {
          var currentZoom = _this.map.getZoom();
          if (currentZoom < initialZoom) {
            _this.map.setZoom(initialZoom);
          }
        });
        //used for debugging. used to click on the map and console.log the coordinates as to setup a way to set the locations.json data to relevant point in the map.  
        this.map.on('click', function (e) {
          console.log('Current Coordinates:', e.latlng);
        });
      }
    }
    // a async function used to fetch the data from the local host. 
  }, {
    key: "fetchLocationsData",
    value: function () {
      var _fetchLocationsData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var response, data;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return fetch('http://localhost:3000/locations');
            case 3:
              response = _context.sent;
              if (response.ok) {
                _context.next = 6;
                break;
              }
              throw new Error("Error: ".concat(response.status, " - ").concat(response.statusText));
            case 6:
              _context.next = 8;
              return response.json();
            case 8:
              data = _context.sent;
              //this.locations variable will be equal to the data variable defined above or a empty array.
              this.locations = data || [];
              //used for testing purposes, will log the locations data. 
              console.log('Locations Data:', this.locations);
              //the addMarkers method will be used to get the actual data from the locations found and add a relative icon to it on the bottom tab(explained further below)
              // both methods below will need to fire the moment the fetch locationsData is fired in order to correctly pass correct icons to the bottom tab.
              this.addMarkers();
              this.addBridgeIconToLocationsTab(); // Add the icon to the bottom tab. 
              // a error to be set up if the locations data is not found. was used for testing purposes. 
              _context.next = 18;
              break;
            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](0);
              console.error('Error fetching locations data:', _context.t0);
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[0, 15]]);
      }));
      function fetchLocationsData() {
        return _fetchLocationsData.apply(this, arguments);
      }
      return fetchLocationsData;
    }() //addMarkers method. Used to get the exact coordinates and type from the locations.json data and pass those values to the bottom tab, making it relative to the icon tab
  }, {
    key: "addMarkers",
    value: function addMarkers() {
      var _this2 = this;
      //set up a for each method with location and index passed as parameters
      this.locations.forEach(function (location, index) {
        //the xCoord, and YCorrd, as well as type is equal to the location
        var XCoord = location.XCoord,
          YCoord = location.YCoord,
          type = location.type;
        //for testing purposes logging the markers index
        console.log('Marker index:', index);
        //the marker now equals the leafletmarker at the object values of YCood and XCoord
        var marker = L.marker([YCoord, XCoord], {
          //within the marker method icon is equal to the customIcon relative to type attribute found in the locations.Json data
          icon: _this2.customIcon(type)
          //add a second property to marker whcih is addTo with the parameter this.map, within add a click event that will return onMarkerClick with the location and index as parameters
        }).addTo(_this2.map).on('click', function () {
          return _this2.onMarkerClick(location, index);
        });

        //set marker._leaflet_id equal to the index found on the click.
        marker._leaflet_id = index;
        //push the marker to marker. 
        _this2.markers.push(marker);
      });
    }

    //onMarkerClick is responsible for determing the output of what happens when you click the map icon on the map. Called above within the addMarker method, below defines it
    //onMarkerClick takes the parameters location, and index. 
  }, {
    key: "onMarkerClick",
    value: function onMarkerClick(location, index) {
      var _this3 = this;
      //set up a constant that equals the location. Basically you are fetching from the location data the name, type, image, stats, description, species, classes, and faction(not implemented) from the data
      var Name = location.Name,
        type = location.type,
        image = location.image,
        stats = location.stats,
        description = location.description,
        species = location.species,
        classes = location.classes,
        faction = location.faction;
      //detailsTab is equal to the details tab ID from the html. It appends the data to the details-tab html in a template literal.
      var detailsTab = document.getElementById('details-tab');
      //console.log the classes data, this was done to test the chart data later defined below. 
      console.log('Classes:', classes);
      //within the detailsTab.innerHTML you are setting the details tab information and its look, felt even with styles it was easier to implemnt in a template literal. each line of the html
      //carries with it the data type from the locations.json relative to the map location. 
      detailsTab.innerHTML = "\n            <h2 style=\"background-color:#00000080; margin-bottom: 1px\">".concat(Name, "</h2>\n            <img src=\"").concat(image, "\" alt=\"").concat(Name, "\">\n            <p style=\"background-color:#00000080; border-radius: 5px;\">Description: ").concat(description, "</p>\n            <div class=\"columns\">\n                <div class=\"details-column\">\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Type: ").concat(type, "</p>\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Population: ").concat(stats.population, "</p>\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">military: ").concat(stats.military, "</p>\n                </div>\n                <div class=\"details-column\">\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Magic: ").concat(stats.magic, "</p>\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Wealth: ").concat(stats.money, "</p>\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Resource: ").concat(stats.resource, "</p>\n                </div>\n                <div class=\"details-column\">\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Govern: ").concat(stats.governance, "</p>\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Tech: ").concat(stats.tech, "</p>\n                    <p style=\"background-color:#00000080; border-radius: 5px;\">Peace: ").concat(stats.peaceLevel, "</p>\n                </div>\n            </div>\n            <h2>Statistics</h2>\n            <div class=\"donut-settings\">  <canvas id=\"donut-chart-").concat(index, "\"> </canvas></div>\n            <div id=\"classes-tab\" class=\"classes-settings\"> <canvas id=\"classes-chart-").concat(index, "\"></canvas></div>\n            \n        ");
      //above the template literal will also setup the chartjs location and what property to pass. In this case it is either donut-chart and the relative index, or classes-chart and its relative index.

      // below is used to set up the chart.js intitialization, if species is true then set a timeout that will call the createDonutChat with its parameters species and relative index. 
      //in the first example, I wanted to set up a time sequence just to experiment, in all reality the timeout is not really neccasary. 
      if (species) {
        setTimeout(function () {
          _this3.createDonutChart(species, index);
        }, 100);
      }
      //if statement that states that if classes is true then render the createClassesChart with classes and relative index passed as its parameters. 
      if (classes) {
        this.createClassesChart(classes, index);
      }

      //below was used to initially set up a third chart. However was not able to get the lines to show up on it for whatever reason, and ran out of time. 

      // if (faction) {
      //     this.createFaction(faction, index);
      // }

      //ensuring that the detailsTab style is set to flex for design purposes. 
      detailsTab.style.display = 'flex';
    }

    //below is used to setup the logic behind the customIcon with its type as a parameter, 
  }, {
    key: "customIcon",
    value: function customIcon(type) {
      //define iconUrl 
      //define iconSize which is equal to 64, 64. 
      //this is relative to leaflet.js's documentation on controling the icon's 
      var iconUrl;
      var iconSize = [64, 64];

      // a switch statement that defines the location type and its relative image per type found in the locations.json
      switch (type) {
        case 'city':
          iconUrl = 'assets/city-icon.png';
          break;
        case 'bridge':
          iconUrl = 'assets/bridge-icon.png';
          break;
        case 'forest':
          iconUrl = 'assets/forest-icon.png';
          break;
        case 'ruins':
          iconUrl = 'assets/ruins-icon.png';
          break;
        case 'mine':
          iconUrl = 'assets/mine-icon.png';
          break;
        case 'sacredsite':
          iconUrl = 'assets/sacredsite-icon.png';
          break;
        case 'ancientBattle':
          iconUrl = 'assets/ancientBattle-icon.png';
          break;
        case 'swamp':
          iconUrl = 'assets/swamp-icon.png';
          break;
        default:
          iconUrl = 'assets/ruins-icon.png';
          break;
      }

      //as per leaflets documentation, you want to return the Leaflet icon with its iconUrl, iconSize, iconAnchor, its popupAnchor, and its type: type. 
      //BIG NOTE: when attempting to create a icon filter where you click the icon image at the bottom tab and it toggles the visibility of the actual map icon. I understood the logic, however, 
      //could not tie it to leaflet's way of handling icons. I struggled for around six hours attempting to figure out why toggleLocationVisibility(type) defined below was not working. As I was 
      //correctly passing the type parameter to the toggleLocationVIsibility. However after hours of debugging I found that within the L.icon, it had to define type: type, otherwise the data just
      //was not connecting to the leaflet customization for the icon. 
      return L.icon({
        iconUrl: iconUrl,
        iconSize: iconSize,
        iconAnchor: [iconSize[0] / 2, iconSize[1] / 2],
        popupAnchor: [0, -iconSize[1] / 2],
        //type: type. this simple key value pair, cuased me hours of debugging and frustration, but eventually found that type: type had be defined in order for the type parameter from the icon to correctly pass
        type: type
      });
    }

    //the createDonutChart is responsible for creating the chart relative to the species data found in locations.json, it takes it parameters species, and index. 
    //majority of the setup for the charts I was able to implement by simply looking over project 6's event application as the way the charts run are similiar.
  }, {
    key: "createDonutChart",
    value: function createDonutChart(species, index) {
      //canvasID is equal to the value `donut-chart-' found in the template literal html, However what is extremelly important is passing the index to the template literal as `donut-chart-${index}`
      // the index placed after the html tag means that the html of donut-chart- is now relative to the species index. 
      //canvas is just attaching a getElementById to the CanvasID defined. 
      var canvasId = "donut-chart-".concat(index);
      var canvas = document.getElementById(canvasId);

      //essential error handling if canvasID is not found - by default it will log an eror becuase it only returns the id once you click on the specific map location
      if (!canvas) {
        // console.log(`Canvas not found for ID: ${canvasId}`);
        return;
      }
      var ctx = canvas.getContext('2d');
      if (typeof Chart === 'undefined') {
        console.error('Chart.js is not loaded or initialized.');
        return;
      }
      if (!species || Object.keys(species).length === 0) {
        console.error('Species data is empty or undefined.');
        return;
      }
      Chart.defaults.global.animation = false;
      //speciesNames and speciesValues are important to be tied to the Object.keys and object.values. this is important becuase for displaying the correct graph key value pairs, these must be
      //defined as key value pairs rendered as objects. 
      var speciesNames = Object.keys(species);
      var speciesValues = Object.values(species);

      //this is directly responsible for the visual display of the species 'doughnut chart'
      new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: speciesNames,
          datasets: [{
            data: speciesValues,
            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],
            hoverBackgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutoutPercentage: 50,
          title: {
            display: true,
            text: 'Species Demographs',
            fontColor: 'white'
          },
          tooltips: {
            enabled: true,
            callbacks: {
              //this is in charge of displaying the values in the tooltip, essentially making the tooltip show the dataset, its total, the currentValue of the dataset, and basically
              //appending a percentage after each value. 
              label: function label(tooltipItem, data) {
                var dataset = data.datasets[tooltipItem.datasetIndex];
                var total = dataset.data.reduce(function (previousValue, currentValue) {
                  return previousValue + currentValue;
                });
                var currentValue = dataset.data[tooltipItem.index];
                var percentage = Math.floor(currentValue / total * 100 + 0.5);
                return "".concat(data.labels[tooltipItem.index], ": ").concat(percentage, "%");
              }
            }
          },
          legend: {
            labels: {
              fontColor: 'white'
            }
          },
          layout: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        }
      });
    }

    //very similiar to above, in fact essentially the same functionality. The createClassesChart method is used to set up the chart for the second graph, where classes and its index are displayed.
  }, {
    key: "createClassesChart",
    value: function createClassesChart(classes, index) {
      //this very key part is shown again, where canvasId is equal to `classes-chart-` then its relative index to the classes parameter. 
      var canvasId = "classes-chart-".concat(index);
      var canvas = document.getElementById(canvasId);
      //console.log for testing purposes, wished to see if the index for classes was passed correctly. - placed as comments becuase it will be defualt pass a not found or undefined until map location clicked
      // console.log(canvasId)
      // console.log(index)
      // console.log('Classes:', classes);
      //error handling if classes index was not found. 
      if (!canvas) {
        // console.error(`Canvas not found for ID: ${canvasId}`); - by default will throw a error as the map location is not clicked
        return;
      }
      var ctx = canvas.getContext('2d');
      if (typeof Chart === 'undefined') {
        console.error('Chart.js is not loaded or initialized.');
        return;
      }
      if (!classes || Object.keys(classes).length === 0) {
        console.error('Classes data is empty or undefined.');
        return;
      }
      Chart.defaults.global.animation = false;
      var classNames = Object.keys(classes);
      var classValues = Object.values(classes);
      console.log('Classes:', classes);
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels: classNames,
          datasets: [{
            data: classValues,
            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF'],
            hoverBackgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutoutPercentage: 50,
          title: {
            display: true,
            text: 'Classes Demographs',
            fontColor: 'white'
          },
          tooltips: {
            enabled: true,
            callbacks: {
              label: function label(tooltipItem, data) {
                var dataset = data.datasets[tooltipItem.datasetIndex];
                var total = dataset.data.reduce(function (previousValue, currentValue) {
                  return previousValue + currentValue;
                });
                var currentValue = dataset.data[tooltipItem.index];
                var percentage = Math.floor(currentValue / total * 100 + 0.5);
                return "".concat(data.labels[tooltipItem.index], ": ").concat(percentage, "%");
              }
            }
          },
          legend: {
            labels: {
              fontColor: 'white'
            }
          },
          layout: {
            padding: {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
            }
          }
        }
      });
    }

    //the below method was created and nearly finished however couldn't figure out the issue with the lines not showing up within the amount of time given. 

    // // Inside createFactionControlChart method

    // createFaction(faction, index) {

    //     const areaLabels = Object.keys(faction);
    //     const factionData = Object.values(faction);

    //     const canvasId = `faction-chart-${index}`;
    //     const canvas = document.getElementById(canvasId);
    //     console.log(`this is canvasID: ${canvasId}`)
    //     console.log(`this is faction: ${faction}`)
    //     console.log(`this is index: ${index}`)
    //     if (!canvas) {
    //         console.error(`Canvas not found for ID: ${canvasId}`);
    //         return;
    //     }

    //     const ctx = canvas.getContext('2d');

    //     new Chart(ctx, {
    //         type: 'line',
    //         data: {
    //             labels: areaLabels,
    //             datasets: factionData.map((faction, i) => ({
    //                 label: `Faction ${i + 1}`,
    //                 data: faction,
    //                 fill: false,
    //                 borderColor: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 1)`,
    //                 borderWidth: 1
    //             }))
    //         },
    //         options: {
    //             responsive: true,
    //             maintainAspectRatio: false,
    //             scales: {
    //                 yAxes: [{ ticks: { beginAtZero: true } }]
    //             }
    //         }
    //     });
    // }

    //below method to define the add icon to the below locations tab. 
  }, {
    key: "addBridgeIconToLocationsTab",
    value: function addBridgeIconToLocationsTab() {
      var _this4 = this;
      //locationsTab is equal to the id of locations tab. 
      var locationsTab = document.getElementById('locations-tab');
      //locationsTab inner HTHML is set to Locations. 
      locationsTab.innerHTML = "Locations";

      // Get unique location types - you want to set the spread of the new Set data at this.locations map where location will return the location.type. Type found of course in the locations.json.
      var uniqueTypes = _toConsumableArray(new Set(this.locations.map(function (location) {
        return location.type;
      })));

      // Create buttons for each unique location type. this will render a button for each unique location type 
      uniqueTypes.forEach(function (type) {
        //button is equal to the document.create button
        var button = document.createElement('button');
        //the buttons text content is equal to the type
        button.textContent = type;
        //add location button class to the button
        button.classList.add('location-button');
        //then add a event listener which is a click event which will return the toggleLOcationVIsibility method with type as its parameter. 
        button.addEventListener('click', function () {
          return _this4.toggleLocationVisibility(type);
        });
        //at the locationsTab, append a child element with button as its parameter 
        locationsTab.appendChild(button);
      });
    }

    //below is the toggleLocationVisibility method with type passed as its parameter 
  }, {
    key: "toggleLocationVisibility",
    value: function toggleLocationVisibility(type) {
      var _this5 = this;
      //for each markers, marker will return a statement with conditional rendering
      this.markers.forEach(function (marker) {
        // if the marker options, markeroptionsicon and marker options icon options are all true then render the locationTpye equal to marker.options.icon.options.type. Which by defualt will be true. 
        if (marker.options && marker.options.icon && marker.options.icon.options) {
          var locationType = marker.options.icon.options.type;
          // if locationType has a type relative to the type found in the location, the map at hasLayer from leaflet with is marker parameter will removethe leaflet layer. meaning remove the leaflet icon
          if (locationType === type) {
            if (_this5.map.hasLayer(marker)) {
              _this5.map.removeLayer(marker);
            } else {
              _this5.map.addLayer(marker);
            }
          } else {
            //basically if the leaflet hasLayer is not true and the button is clicked, it will then make the icon appear, hasLayer(marker)
            if (!_this5.map.hasLayer(marker)) {
              _this5.map.addLayer(marker);
            }
          }
          //if the marker icon is not defined or found, then a error will apear to the console. 
        } else {
          console.error('Marker icon options are undefined or do not exist.');
        }
      });
    }
  }]);
  return FantasyMap;
}(); //call the class FantasyMap within a constant called fantasyMap
var fantasyMap = new FantasyMap();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OytDQUNBLHFKQUFBQSxtQkFBQSxZQUFBQSxvQkFBQSxXQUFBQyxDQUFBLFNBQUFDLENBQUEsRUFBQUQsQ0FBQSxPQUFBRSxDQUFBLEdBQUFDLE1BQUEsQ0FBQUMsU0FBQSxFQUFBQyxDQUFBLEdBQUFILENBQUEsQ0FBQUksY0FBQSxFQUFBQyxDQUFBLEdBQUFKLE1BQUEsQ0FBQUssY0FBQSxjQUFBUCxDQUFBLEVBQUFELENBQUEsRUFBQUUsQ0FBQSxJQUFBRCxDQUFBLENBQUFELENBQUEsSUFBQUUsQ0FBQSxDQUFBTyxLQUFBLEtBQUFDLENBQUEsd0JBQUFDLE1BQUEsR0FBQUEsTUFBQSxPQUFBQyxDQUFBLEdBQUFGLENBQUEsQ0FBQUcsUUFBQSxrQkFBQUMsQ0FBQSxHQUFBSixDQUFBLENBQUFLLGFBQUEsdUJBQUFDLENBQUEsR0FBQU4sQ0FBQSxDQUFBTyxXQUFBLDhCQUFBQyxPQUFBakIsQ0FBQSxFQUFBRCxDQUFBLEVBQUFFLENBQUEsV0FBQUMsTUFBQSxDQUFBSyxjQUFBLENBQUFQLENBQUEsRUFBQUQsQ0FBQSxJQUFBUyxLQUFBLEVBQUFQLENBQUEsRUFBQWlCLFVBQUEsTUFBQUMsWUFBQSxNQUFBQyxRQUFBLFNBQUFwQixDQUFBLENBQUFELENBQUEsV0FBQWtCLE1BQUEsbUJBQUFqQixDQUFBLElBQUFpQixNQUFBLFlBQUFBLE9BQUFqQixDQUFBLEVBQUFELENBQUEsRUFBQUUsQ0FBQSxXQUFBRCxDQUFBLENBQUFELENBQUEsSUFBQUUsQ0FBQSxnQkFBQW9CLEtBQUFyQixDQUFBLEVBQUFELENBQUEsRUFBQUUsQ0FBQSxFQUFBRyxDQUFBLFFBQUFLLENBQUEsR0FBQVYsQ0FBQSxJQUFBQSxDQUFBLENBQUFJLFNBQUEsWUFBQW1CLFNBQUEsR0FBQXZCLENBQUEsR0FBQXVCLFNBQUEsRUFBQVgsQ0FBQSxHQUFBVCxNQUFBLENBQUFxQixNQUFBLENBQUFkLENBQUEsQ0FBQU4sU0FBQSxHQUFBVSxDQUFBLE9BQUFXLE9BQUEsQ0FBQXBCLENBQUEsZ0JBQUFFLENBQUEsQ0FBQUssQ0FBQSxlQUFBSCxLQUFBLEVBQUFpQixnQkFBQSxDQUFBekIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFZLENBQUEsTUFBQUYsQ0FBQSxhQUFBZSxTQUFBMUIsQ0FBQSxFQUFBRCxDQUFBLEVBQUFFLENBQUEsbUJBQUEwQixJQUFBLFlBQUFDLEdBQUEsRUFBQTVCLENBQUEsQ0FBQTZCLElBQUEsQ0FBQTlCLENBQUEsRUFBQUUsQ0FBQSxjQUFBRCxDQUFBLGFBQUEyQixJQUFBLFdBQUFDLEdBQUEsRUFBQTVCLENBQUEsUUFBQUQsQ0FBQSxDQUFBc0IsSUFBQSxHQUFBQSxJQUFBLE1BQUFTLENBQUEscUJBQUFDLENBQUEscUJBQUFDLENBQUEsZ0JBQUFDLENBQUEsZ0JBQUFDLENBQUEsZ0JBQUFaLFVBQUEsY0FBQWEsa0JBQUEsY0FBQUMsMkJBQUEsU0FBQUMsQ0FBQSxPQUFBcEIsTUFBQSxDQUFBb0IsQ0FBQSxFQUFBMUIsQ0FBQSxxQ0FBQTJCLENBQUEsR0FBQXBDLE1BQUEsQ0FBQXFDLGNBQUEsRUFBQUMsQ0FBQSxHQUFBRixDQUFBLElBQUFBLENBQUEsQ0FBQUEsQ0FBQSxDQUFBRyxNQUFBLFFBQUFELENBQUEsSUFBQUEsQ0FBQSxLQUFBdkMsQ0FBQSxJQUFBRyxDQUFBLENBQUF5QixJQUFBLENBQUFXLENBQUEsRUFBQTdCLENBQUEsTUFBQTBCLENBQUEsR0FBQUcsQ0FBQSxPQUFBRSxDQUFBLEdBQUFOLDBCQUFBLENBQUFqQyxTQUFBLEdBQUFtQixTQUFBLENBQUFuQixTQUFBLEdBQUFELE1BQUEsQ0FBQXFCLE1BQUEsQ0FBQWMsQ0FBQSxZQUFBTSxzQkFBQTNDLENBQUEsZ0NBQUE0QyxPQUFBLFdBQUE3QyxDQUFBLElBQUFrQixNQUFBLENBQUFqQixDQUFBLEVBQUFELENBQUEsWUFBQUMsQ0FBQSxnQkFBQTZDLE9BQUEsQ0FBQTlDLENBQUEsRUFBQUMsQ0FBQSxzQkFBQThDLGNBQUE5QyxDQUFBLEVBQUFELENBQUEsYUFBQWdELE9BQUE5QyxDQUFBLEVBQUFLLENBQUEsRUFBQUcsQ0FBQSxFQUFBRSxDQUFBLFFBQUFFLENBQUEsR0FBQWEsUUFBQSxDQUFBMUIsQ0FBQSxDQUFBQyxDQUFBLEdBQUFELENBQUEsRUFBQU0sQ0FBQSxtQkFBQU8sQ0FBQSxDQUFBYyxJQUFBLFFBQUFaLENBQUEsR0FBQUYsQ0FBQSxDQUFBZSxHQUFBLEVBQUFFLENBQUEsR0FBQWYsQ0FBQSxDQUFBUCxLQUFBLFNBQUFzQixDQUFBLGdCQUFBa0IsT0FBQSxDQUFBbEIsQ0FBQSxLQUFBMUIsQ0FBQSxDQUFBeUIsSUFBQSxDQUFBQyxDQUFBLGVBQUEvQixDQUFBLENBQUFrRCxPQUFBLENBQUFuQixDQUFBLENBQUFvQixPQUFBLEVBQUFDLElBQUEsV0FBQW5ELENBQUEsSUFBQStDLE1BQUEsU0FBQS9DLENBQUEsRUFBQVMsQ0FBQSxFQUFBRSxDQUFBLGdCQUFBWCxDQUFBLElBQUErQyxNQUFBLFVBQUEvQyxDQUFBLEVBQUFTLENBQUEsRUFBQUUsQ0FBQSxRQUFBWixDQUFBLENBQUFrRCxPQUFBLENBQUFuQixDQUFBLEVBQUFxQixJQUFBLFdBQUFuRCxDQUFBLElBQUFlLENBQUEsQ0FBQVAsS0FBQSxHQUFBUixDQUFBLEVBQUFTLENBQUEsQ0FBQU0sQ0FBQSxnQkFBQWYsQ0FBQSxXQUFBK0MsTUFBQSxVQUFBL0MsQ0FBQSxFQUFBUyxDQUFBLEVBQUFFLENBQUEsU0FBQUEsQ0FBQSxDQUFBRSxDQUFBLENBQUFlLEdBQUEsU0FBQTNCLENBQUEsRUFBQUssQ0FBQSxvQkFBQUUsS0FBQSxXQUFBQSxNQUFBUixDQUFBLEVBQUFJLENBQUEsYUFBQWdELDJCQUFBLGVBQUFyRCxDQUFBLFdBQUFBLENBQUEsRUFBQUUsQ0FBQSxJQUFBOEMsTUFBQSxDQUFBL0MsQ0FBQSxFQUFBSSxDQUFBLEVBQUFMLENBQUEsRUFBQUUsQ0FBQSxnQkFBQUEsQ0FBQSxHQUFBQSxDQUFBLEdBQUFBLENBQUEsQ0FBQWtELElBQUEsQ0FBQUMsMEJBQUEsRUFBQUEsMEJBQUEsSUFBQUEsMEJBQUEscUJBQUEzQixpQkFBQTFCLENBQUEsRUFBQUUsQ0FBQSxFQUFBRyxDQUFBLFFBQUFFLENBQUEsR0FBQXdCLENBQUEsbUJBQUFyQixDQUFBLEVBQUFFLENBQUEsUUFBQUwsQ0FBQSxLQUFBMEIsQ0FBQSxZQUFBcUIsS0FBQSxzQ0FBQS9DLENBQUEsS0FBQTJCLENBQUEsb0JBQUF4QixDQUFBLFFBQUFFLENBQUEsV0FBQUgsS0FBQSxFQUFBUixDQUFBLEVBQUFzRCxJQUFBLGVBQUFsRCxDQUFBLENBQUFtRCxNQUFBLEdBQUE5QyxDQUFBLEVBQUFMLENBQUEsQ0FBQXdCLEdBQUEsR0FBQWpCLENBQUEsVUFBQUUsQ0FBQSxHQUFBVCxDQUFBLENBQUFvRCxRQUFBLE1BQUEzQyxDQUFBLFFBQUFFLENBQUEsR0FBQTBDLG1CQUFBLENBQUE1QyxDQUFBLEVBQUFULENBQUEsT0FBQVcsQ0FBQSxRQUFBQSxDQUFBLEtBQUFtQixDQUFBLG1CQUFBbkIsQ0FBQSxxQkFBQVgsQ0FBQSxDQUFBbUQsTUFBQSxFQUFBbkQsQ0FBQSxDQUFBc0QsSUFBQSxHQUFBdEQsQ0FBQSxDQUFBdUQsS0FBQSxHQUFBdkQsQ0FBQSxDQUFBd0IsR0FBQSxzQkFBQXhCLENBQUEsQ0FBQW1ELE1BQUEsUUFBQWpELENBQUEsS0FBQXdCLENBQUEsUUFBQXhCLENBQUEsR0FBQTJCLENBQUEsRUFBQTdCLENBQUEsQ0FBQXdCLEdBQUEsRUFBQXhCLENBQUEsQ0FBQXdELGlCQUFBLENBQUF4RCxDQUFBLENBQUF3QixHQUFBLHVCQUFBeEIsQ0FBQSxDQUFBbUQsTUFBQSxJQUFBbkQsQ0FBQSxDQUFBeUQsTUFBQSxXQUFBekQsQ0FBQSxDQUFBd0IsR0FBQSxHQUFBdEIsQ0FBQSxHQUFBMEIsQ0FBQSxNQUFBSyxDQUFBLEdBQUFYLFFBQUEsQ0FBQTNCLENBQUEsRUFBQUUsQ0FBQSxFQUFBRyxDQUFBLG9CQUFBaUMsQ0FBQSxDQUFBVixJQUFBLFFBQUFyQixDQUFBLEdBQUFGLENBQUEsQ0FBQWtELElBQUEsR0FBQXJCLENBQUEsR0FBQUYsQ0FBQSxFQUFBTSxDQUFBLENBQUFULEdBQUEsS0FBQU0sQ0FBQSxxQkFBQTFCLEtBQUEsRUFBQTZCLENBQUEsQ0FBQVQsR0FBQSxFQUFBMEIsSUFBQSxFQUFBbEQsQ0FBQSxDQUFBa0QsSUFBQSxrQkFBQWpCLENBQUEsQ0FBQVYsSUFBQSxLQUFBckIsQ0FBQSxHQUFBMkIsQ0FBQSxFQUFBN0IsQ0FBQSxDQUFBbUQsTUFBQSxZQUFBbkQsQ0FBQSxDQUFBd0IsR0FBQSxHQUFBUyxDQUFBLENBQUFULEdBQUEsbUJBQUE2QixvQkFBQTFELENBQUEsRUFBQUUsQ0FBQSxRQUFBRyxDQUFBLEdBQUFILENBQUEsQ0FBQXNELE1BQUEsRUFBQWpELENBQUEsR0FBQVAsQ0FBQSxDQUFBYSxRQUFBLENBQUFSLENBQUEsT0FBQUUsQ0FBQSxLQUFBTixDQUFBLFNBQUFDLENBQUEsQ0FBQXVELFFBQUEscUJBQUFwRCxDQUFBLElBQUFMLENBQUEsQ0FBQWEsUUFBQSxlQUFBWCxDQUFBLENBQUFzRCxNQUFBLGFBQUF0RCxDQUFBLENBQUEyQixHQUFBLEdBQUE1QixDQUFBLEVBQUF5RCxtQkFBQSxDQUFBMUQsQ0FBQSxFQUFBRSxDQUFBLGVBQUFBLENBQUEsQ0FBQXNELE1BQUEsa0JBQUFuRCxDQUFBLEtBQUFILENBQUEsQ0FBQXNELE1BQUEsWUFBQXRELENBQUEsQ0FBQTJCLEdBQUEsT0FBQWtDLFNBQUEsdUNBQUExRCxDQUFBLGlCQUFBOEIsQ0FBQSxNQUFBekIsQ0FBQSxHQUFBaUIsUUFBQSxDQUFBcEIsQ0FBQSxFQUFBUCxDQUFBLENBQUFhLFFBQUEsRUFBQVgsQ0FBQSxDQUFBMkIsR0FBQSxtQkFBQW5CLENBQUEsQ0FBQWtCLElBQUEsU0FBQTFCLENBQUEsQ0FBQXNELE1BQUEsWUFBQXRELENBQUEsQ0FBQTJCLEdBQUEsR0FBQW5CLENBQUEsQ0FBQW1CLEdBQUEsRUFBQTNCLENBQUEsQ0FBQXVELFFBQUEsU0FBQXRCLENBQUEsTUFBQXZCLENBQUEsR0FBQUYsQ0FBQSxDQUFBbUIsR0FBQSxTQUFBakIsQ0FBQSxHQUFBQSxDQUFBLENBQUEyQyxJQUFBLElBQUFyRCxDQUFBLENBQUFGLENBQUEsQ0FBQWdFLFVBQUEsSUFBQXBELENBQUEsQ0FBQUgsS0FBQSxFQUFBUCxDQUFBLENBQUErRCxJQUFBLEdBQUFqRSxDQUFBLENBQUFrRSxPQUFBLGVBQUFoRSxDQUFBLENBQUFzRCxNQUFBLEtBQUF0RCxDQUFBLENBQUFzRCxNQUFBLFdBQUF0RCxDQUFBLENBQUEyQixHQUFBLEdBQUE1QixDQUFBLEdBQUFDLENBQUEsQ0FBQXVELFFBQUEsU0FBQXRCLENBQUEsSUFBQXZCLENBQUEsSUFBQVYsQ0FBQSxDQUFBc0QsTUFBQSxZQUFBdEQsQ0FBQSxDQUFBMkIsR0FBQSxPQUFBa0MsU0FBQSxzQ0FBQTdELENBQUEsQ0FBQXVELFFBQUEsU0FBQXRCLENBQUEsY0FBQWdDLGFBQUFsRSxDQUFBLFFBQUFELENBQUEsS0FBQW9FLE1BQUEsRUFBQW5FLENBQUEsWUFBQUEsQ0FBQSxLQUFBRCxDQUFBLENBQUFxRSxRQUFBLEdBQUFwRSxDQUFBLFdBQUFBLENBQUEsS0FBQUQsQ0FBQSxDQUFBc0UsVUFBQSxHQUFBckUsQ0FBQSxLQUFBRCxDQUFBLENBQUF1RSxRQUFBLEdBQUF0RSxDQUFBLFdBQUF1RSxVQUFBLENBQUFDLElBQUEsQ0FBQXpFLENBQUEsY0FBQTBFLGNBQUF6RSxDQUFBLFFBQUFELENBQUEsR0FBQUMsQ0FBQSxDQUFBMEUsVUFBQSxRQUFBM0UsQ0FBQSxDQUFBNEIsSUFBQSxvQkFBQTVCLENBQUEsQ0FBQTZCLEdBQUEsRUFBQTVCLENBQUEsQ0FBQTBFLFVBQUEsR0FBQTNFLENBQUEsYUFBQXlCLFFBQUF4QixDQUFBLFNBQUF1RSxVQUFBLE1BQUFKLE1BQUEsYUFBQW5FLENBQUEsQ0FBQTRDLE9BQUEsQ0FBQXNCLFlBQUEsY0FBQVMsS0FBQSxpQkFBQWxDLE9BQUExQyxDQUFBLFFBQUFBLENBQUEsV0FBQUEsQ0FBQSxRQUFBRSxDQUFBLEdBQUFGLENBQUEsQ0FBQVksQ0FBQSxPQUFBVixDQUFBLFNBQUFBLENBQUEsQ0FBQTRCLElBQUEsQ0FBQTlCLENBQUEsNEJBQUFBLENBQUEsQ0FBQWlFLElBQUEsU0FBQWpFLENBQUEsT0FBQTZFLEtBQUEsQ0FBQTdFLENBQUEsQ0FBQThFLE1BQUEsU0FBQXZFLENBQUEsT0FBQUcsQ0FBQSxZQUFBdUQsS0FBQSxhQUFBMUQsQ0FBQSxHQUFBUCxDQUFBLENBQUE4RSxNQUFBLE9BQUF6RSxDQUFBLENBQUF5QixJQUFBLENBQUE5QixDQUFBLEVBQUFPLENBQUEsVUFBQTBELElBQUEsQ0FBQXhELEtBQUEsR0FBQVQsQ0FBQSxDQUFBTyxDQUFBLEdBQUEwRCxJQUFBLENBQUFWLElBQUEsT0FBQVUsSUFBQSxTQUFBQSxJQUFBLENBQUF4RCxLQUFBLEdBQUFSLENBQUEsRUFBQWdFLElBQUEsQ0FBQVYsSUFBQSxPQUFBVSxJQUFBLFlBQUF2RCxDQUFBLENBQUF1RCxJQUFBLEdBQUF2RCxDQUFBLGdCQUFBcUQsU0FBQSxDQUFBZCxPQUFBLENBQUFqRCxDQUFBLGtDQUFBb0MsaUJBQUEsQ0FBQWhDLFNBQUEsR0FBQWlDLDBCQUFBLEVBQUE5QixDQUFBLENBQUFvQyxDQUFBLG1CQUFBbEMsS0FBQSxFQUFBNEIsMEJBQUEsRUFBQWpCLFlBQUEsU0FBQWIsQ0FBQSxDQUFBOEIsMEJBQUEsbUJBQUE1QixLQUFBLEVBQUEyQixpQkFBQSxFQUFBaEIsWUFBQSxTQUFBZ0IsaUJBQUEsQ0FBQTJDLFdBQUEsR0FBQTdELE1BQUEsQ0FBQW1CLDBCQUFBLEVBQUFyQixDQUFBLHdCQUFBaEIsQ0FBQSxDQUFBZ0YsbUJBQUEsYUFBQS9FLENBQUEsUUFBQUQsQ0FBQSx3QkFBQUMsQ0FBQSxJQUFBQSxDQUFBLENBQUFnRixXQUFBLFdBQUFqRixDQUFBLEtBQUFBLENBQUEsS0FBQW9DLGlCQUFBLDZCQUFBcEMsQ0FBQSxDQUFBK0UsV0FBQSxJQUFBL0UsQ0FBQSxDQUFBa0YsSUFBQSxPQUFBbEYsQ0FBQSxDQUFBbUYsSUFBQSxhQUFBbEYsQ0FBQSxXQUFBRSxNQUFBLENBQUFpRixjQUFBLEdBQUFqRixNQUFBLENBQUFpRixjQUFBLENBQUFuRixDQUFBLEVBQUFvQywwQkFBQSxLQUFBcEMsQ0FBQSxDQUFBb0YsU0FBQSxHQUFBaEQsMEJBQUEsRUFBQW5CLE1BQUEsQ0FBQWpCLENBQUEsRUFBQWUsQ0FBQSx5QkFBQWYsQ0FBQSxDQUFBRyxTQUFBLEdBQUFELE1BQUEsQ0FBQXFCLE1BQUEsQ0FBQW1CLENBQUEsR0FBQTFDLENBQUEsS0FBQUQsQ0FBQSxDQUFBc0YsS0FBQSxhQUFBckYsQ0FBQSxhQUFBa0QsT0FBQSxFQUFBbEQsQ0FBQSxPQUFBMkMscUJBQUEsQ0FBQUcsYUFBQSxDQUFBM0MsU0FBQSxHQUFBYyxNQUFBLENBQUE2QixhQUFBLENBQUEzQyxTQUFBLEVBQUFVLENBQUEsaUNBQUFkLENBQUEsQ0FBQStDLGFBQUEsR0FBQUEsYUFBQSxFQUFBL0MsQ0FBQSxDQUFBdUYsS0FBQSxhQUFBdEYsQ0FBQSxFQUFBQyxDQUFBLEVBQUFHLENBQUEsRUFBQUUsQ0FBQSxFQUFBRyxDQUFBLGVBQUFBLENBQUEsS0FBQUEsQ0FBQSxHQUFBOEUsT0FBQSxPQUFBNUUsQ0FBQSxPQUFBbUMsYUFBQSxDQUFBekIsSUFBQSxDQUFBckIsQ0FBQSxFQUFBQyxDQUFBLEVBQUFHLENBQUEsRUFBQUUsQ0FBQSxHQUFBRyxDQUFBLFVBQUFWLENBQUEsQ0FBQWdGLG1CQUFBLENBQUE5RSxDQUFBLElBQUFVLENBQUEsR0FBQUEsQ0FBQSxDQUFBcUQsSUFBQSxHQUFBYixJQUFBLFdBQUFuRCxDQUFBLFdBQUFBLENBQUEsQ0FBQXNELElBQUEsR0FBQXRELENBQUEsQ0FBQVEsS0FBQSxHQUFBRyxDQUFBLENBQUFxRCxJQUFBLFdBQUFyQixxQkFBQSxDQUFBRCxDQUFBLEdBQUF6QixNQUFBLENBQUF5QixDQUFBLEVBQUEzQixDQUFBLGdCQUFBRSxNQUFBLENBQUF5QixDQUFBLEVBQUEvQixDQUFBLGlDQUFBTSxNQUFBLENBQUF5QixDQUFBLDZEQUFBM0MsQ0FBQSxDQUFBeUYsSUFBQSxhQUFBeEYsQ0FBQSxRQUFBRCxDQUFBLEdBQUFHLE1BQUEsQ0FBQUYsQ0FBQSxHQUFBQyxDQUFBLGdCQUFBRyxDQUFBLElBQUFMLENBQUEsRUFBQUUsQ0FBQSxDQUFBdUUsSUFBQSxDQUFBcEUsQ0FBQSxVQUFBSCxDQUFBLENBQUF3RixPQUFBLGFBQUF6QixLQUFBLFdBQUEvRCxDQUFBLENBQUE0RSxNQUFBLFNBQUE3RSxDQUFBLEdBQUFDLENBQUEsQ0FBQXlGLEdBQUEsUUFBQTFGLENBQUEsSUFBQUQsQ0FBQSxTQUFBaUUsSUFBQSxDQUFBeEQsS0FBQSxHQUFBUixDQUFBLEVBQUFnRSxJQUFBLENBQUFWLElBQUEsT0FBQVUsSUFBQSxXQUFBQSxJQUFBLENBQUFWLElBQUEsT0FBQVUsSUFBQSxRQUFBakUsQ0FBQSxDQUFBMEMsTUFBQSxHQUFBQSxNQUFBLEVBQUFqQixPQUFBLENBQUFyQixTQUFBLEtBQUE2RSxXQUFBLEVBQUF4RCxPQUFBLEVBQUFtRCxLQUFBLFdBQUFBLE1BQUE1RSxDQUFBLGFBQUE0RixJQUFBLFdBQUEzQixJQUFBLFdBQUFOLElBQUEsUUFBQUMsS0FBQSxHQUFBM0QsQ0FBQSxPQUFBc0QsSUFBQSxZQUFBRSxRQUFBLGNBQUFELE1BQUEsZ0JBQUEzQixHQUFBLEdBQUE1QixDQUFBLE9BQUF1RSxVQUFBLENBQUEzQixPQUFBLENBQUE2QixhQUFBLElBQUExRSxDQUFBLFdBQUFFLENBQUEsa0JBQUFBLENBQUEsQ0FBQTJGLE1BQUEsT0FBQXhGLENBQUEsQ0FBQXlCLElBQUEsT0FBQTVCLENBQUEsTUFBQTJFLEtBQUEsRUFBQTNFLENBQUEsQ0FBQTRGLEtBQUEsY0FBQTVGLENBQUEsSUFBQUQsQ0FBQSxNQUFBOEYsSUFBQSxXQUFBQSxLQUFBLFNBQUF4QyxJQUFBLFdBQUF0RCxDQUFBLFFBQUF1RSxVQUFBLElBQUFHLFVBQUEsa0JBQUExRSxDQUFBLENBQUEyQixJQUFBLFFBQUEzQixDQUFBLENBQUE0QixHQUFBLGNBQUFtRSxJQUFBLEtBQUFuQyxpQkFBQSxXQUFBQSxrQkFBQTdELENBQUEsYUFBQXVELElBQUEsUUFBQXZELENBQUEsTUFBQUUsQ0FBQSxrQkFBQStGLE9BQUE1RixDQUFBLEVBQUFFLENBQUEsV0FBQUssQ0FBQSxDQUFBZ0IsSUFBQSxZQUFBaEIsQ0FBQSxDQUFBaUIsR0FBQSxHQUFBN0IsQ0FBQSxFQUFBRSxDQUFBLENBQUErRCxJQUFBLEdBQUE1RCxDQUFBLEVBQUFFLENBQUEsS0FBQUwsQ0FBQSxDQUFBc0QsTUFBQSxXQUFBdEQsQ0FBQSxDQUFBMkIsR0FBQSxHQUFBNUIsQ0FBQSxLQUFBTSxDQUFBLGFBQUFBLENBQUEsUUFBQWlFLFVBQUEsQ0FBQU0sTUFBQSxNQUFBdkUsQ0FBQSxTQUFBQSxDQUFBLFFBQUFHLENBQUEsUUFBQThELFVBQUEsQ0FBQWpFLENBQUEsR0FBQUssQ0FBQSxHQUFBRixDQUFBLENBQUFpRSxVQUFBLGlCQUFBakUsQ0FBQSxDQUFBMEQsTUFBQSxTQUFBNkIsTUFBQSxhQUFBdkYsQ0FBQSxDQUFBMEQsTUFBQSxTQUFBd0IsSUFBQSxRQUFBOUUsQ0FBQSxHQUFBVCxDQUFBLENBQUF5QixJQUFBLENBQUFwQixDQUFBLGVBQUFNLENBQUEsR0FBQVgsQ0FBQSxDQUFBeUIsSUFBQSxDQUFBcEIsQ0FBQSxxQkFBQUksQ0FBQSxJQUFBRSxDQUFBLGFBQUE0RSxJQUFBLEdBQUFsRixDQUFBLENBQUEyRCxRQUFBLFNBQUE0QixNQUFBLENBQUF2RixDQUFBLENBQUEyRCxRQUFBLGdCQUFBdUIsSUFBQSxHQUFBbEYsQ0FBQSxDQUFBNEQsVUFBQSxTQUFBMkIsTUFBQSxDQUFBdkYsQ0FBQSxDQUFBNEQsVUFBQSxjQUFBeEQsQ0FBQSxhQUFBOEUsSUFBQSxHQUFBbEYsQ0FBQSxDQUFBMkQsUUFBQSxTQUFBNEIsTUFBQSxDQUFBdkYsQ0FBQSxDQUFBMkQsUUFBQSxxQkFBQXJELENBQUEsWUFBQXNDLEtBQUEscURBQUFzQyxJQUFBLEdBQUFsRixDQUFBLENBQUE0RCxVQUFBLFNBQUEyQixNQUFBLENBQUF2RixDQUFBLENBQUE0RCxVQUFBLFlBQUFSLE1BQUEsV0FBQUEsT0FBQTdELENBQUEsRUFBQUQsQ0FBQSxhQUFBRSxDQUFBLFFBQUFzRSxVQUFBLENBQUFNLE1BQUEsTUFBQTVFLENBQUEsU0FBQUEsQ0FBQSxRQUFBSyxDQUFBLFFBQUFpRSxVQUFBLENBQUF0RSxDQUFBLE9BQUFLLENBQUEsQ0FBQTZELE1BQUEsU0FBQXdCLElBQUEsSUFBQXZGLENBQUEsQ0FBQXlCLElBQUEsQ0FBQXZCLENBQUEsd0JBQUFxRixJQUFBLEdBQUFyRixDQUFBLENBQUErRCxVQUFBLFFBQUE1RCxDQUFBLEdBQUFILENBQUEsYUFBQUcsQ0FBQSxpQkFBQVQsQ0FBQSxtQkFBQUEsQ0FBQSxLQUFBUyxDQUFBLENBQUEwRCxNQUFBLElBQUFwRSxDQUFBLElBQUFBLENBQUEsSUFBQVUsQ0FBQSxDQUFBNEQsVUFBQSxLQUFBNUQsQ0FBQSxjQUFBRSxDQUFBLEdBQUFGLENBQUEsR0FBQUEsQ0FBQSxDQUFBaUUsVUFBQSxjQUFBL0QsQ0FBQSxDQUFBZ0IsSUFBQSxHQUFBM0IsQ0FBQSxFQUFBVyxDQUFBLENBQUFpQixHQUFBLEdBQUE3QixDQUFBLEVBQUFVLENBQUEsU0FBQThDLE1BQUEsZ0JBQUFTLElBQUEsR0FBQXZELENBQUEsQ0FBQTRELFVBQUEsRUFBQW5DLENBQUEsU0FBQStELFFBQUEsQ0FBQXRGLENBQUEsTUFBQXNGLFFBQUEsV0FBQUEsU0FBQWpHLENBQUEsRUFBQUQsQ0FBQSxvQkFBQUMsQ0FBQSxDQUFBMkIsSUFBQSxRQUFBM0IsQ0FBQSxDQUFBNEIsR0FBQSxxQkFBQTVCLENBQUEsQ0FBQTJCLElBQUEsbUJBQUEzQixDQUFBLENBQUEyQixJQUFBLFFBQUFxQyxJQUFBLEdBQUFoRSxDQUFBLENBQUE0QixHQUFBLGdCQUFBNUIsQ0FBQSxDQUFBMkIsSUFBQSxTQUFBb0UsSUFBQSxRQUFBbkUsR0FBQSxHQUFBNUIsQ0FBQSxDQUFBNEIsR0FBQSxPQUFBMkIsTUFBQSxrQkFBQVMsSUFBQSx5QkFBQWhFLENBQUEsQ0FBQTJCLElBQUEsSUFBQTVCLENBQUEsVUFBQWlFLElBQUEsR0FBQWpFLENBQUEsR0FBQW1DLENBQUEsS0FBQWdFLE1BQUEsV0FBQUEsT0FBQWxHLENBQUEsYUFBQUQsQ0FBQSxRQUFBd0UsVUFBQSxDQUFBTSxNQUFBLE1BQUE5RSxDQUFBLFNBQUFBLENBQUEsUUFBQUUsQ0FBQSxRQUFBc0UsVUFBQSxDQUFBeEUsQ0FBQSxPQUFBRSxDQUFBLENBQUFvRSxVQUFBLEtBQUFyRSxDQUFBLGNBQUFpRyxRQUFBLENBQUFoRyxDQUFBLENBQUF5RSxVQUFBLEVBQUF6RSxDQUFBLENBQUFxRSxRQUFBLEdBQUFHLGFBQUEsQ0FBQXhFLENBQUEsR0FBQWlDLENBQUEseUJBQUFpRSxPQUFBbkcsQ0FBQSxhQUFBRCxDQUFBLFFBQUF3RSxVQUFBLENBQUFNLE1BQUEsTUFBQTlFLENBQUEsU0FBQUEsQ0FBQSxRQUFBRSxDQUFBLFFBQUFzRSxVQUFBLENBQUF4RSxDQUFBLE9BQUFFLENBQUEsQ0FBQWtFLE1BQUEsS0FBQW5FLENBQUEsUUFBQUksQ0FBQSxHQUFBSCxDQUFBLENBQUF5RSxVQUFBLGtCQUFBdEUsQ0FBQSxDQUFBdUIsSUFBQSxRQUFBckIsQ0FBQSxHQUFBRixDQUFBLENBQUF3QixHQUFBLEVBQUE2QyxhQUFBLENBQUF4RSxDQUFBLFlBQUFLLENBQUEsZ0JBQUErQyxLQUFBLDhCQUFBK0MsYUFBQSxXQUFBQSxjQUFBckcsQ0FBQSxFQUFBRSxDQUFBLEVBQUFHLENBQUEsZ0JBQUFvRCxRQUFBLEtBQUE1QyxRQUFBLEVBQUE2QixNQUFBLENBQUExQyxDQUFBLEdBQUFnRSxVQUFBLEVBQUE5RCxDQUFBLEVBQUFnRSxPQUFBLEVBQUE3RCxDQUFBLG9CQUFBbUQsTUFBQSxVQUFBM0IsR0FBQSxHQUFBNUIsQ0FBQSxHQUFBa0MsQ0FBQSxPQUFBbkMsQ0FBQTtBQUFBLFNBQUFzRyxtQkFBQUMsR0FBQSxFQUFBckQsT0FBQSxFQUFBc0QsTUFBQSxFQUFBQyxLQUFBLEVBQUFDLE1BQUEsRUFBQUMsR0FBQSxFQUFBOUUsR0FBQSxjQUFBK0UsSUFBQSxHQUFBTCxHQUFBLENBQUFJLEdBQUEsRUFBQTlFLEdBQUEsT0FBQXBCLEtBQUEsR0FBQW1HLElBQUEsQ0FBQW5HLEtBQUEsV0FBQW9HLEtBQUEsSUFBQUwsTUFBQSxDQUFBSyxLQUFBLGlCQUFBRCxJQUFBLENBQUFyRCxJQUFBLElBQUFMLE9BQUEsQ0FBQXpDLEtBQUEsWUFBQStFLE9BQUEsQ0FBQXRDLE9BQUEsQ0FBQXpDLEtBQUEsRUFBQTJDLElBQUEsQ0FBQXFELEtBQUEsRUFBQUMsTUFBQTtBQUFBLFNBQUFJLGtCQUFBQyxFQUFBLDZCQUFBQyxJQUFBLFNBQUFDLElBQUEsR0FBQUMsU0FBQSxhQUFBMUIsT0FBQSxXQUFBdEMsT0FBQSxFQUFBc0QsTUFBQSxRQUFBRCxHQUFBLEdBQUFRLEVBQUEsQ0FBQUksS0FBQSxDQUFBSCxJQUFBLEVBQUFDLElBQUEsWUFBQVIsTUFBQWhHLEtBQUEsSUFBQTZGLGtCQUFBLENBQUFDLEdBQUEsRUFBQXJELE9BQUEsRUFBQXNELE1BQUEsRUFBQUMsS0FBQSxFQUFBQyxNQUFBLFVBQUFqRyxLQUFBLGNBQUFpRyxPQUFBVSxHQUFBLElBQUFkLGtCQUFBLENBQUFDLEdBQUEsRUFBQXJELE9BQUEsRUFBQXNELE1BQUEsRUFBQUMsS0FBQSxFQUFBQyxNQUFBLFdBQUFVLEdBQUEsS0FBQVgsS0FBQSxDQUFBWSxTQUFBO0FBQUEsU0FBQUMsZ0JBQUFDLFFBQUEsRUFBQUMsV0FBQSxVQUFBRCxRQUFBLFlBQUFDLFdBQUEsZUFBQXpELFNBQUE7QUFBQSxTQUFBMEQsa0JBQUFDLE1BQUEsRUFBQUMsS0FBQSxhQUFBakgsQ0FBQSxNQUFBQSxDQUFBLEdBQUFpSCxLQUFBLENBQUE3QyxNQUFBLEVBQUFwRSxDQUFBLFVBQUFrSCxVQUFBLEdBQUFELEtBQUEsQ0FBQWpILENBQUEsR0FBQWtILFVBQUEsQ0FBQXpHLFVBQUEsR0FBQXlHLFVBQUEsQ0FBQXpHLFVBQUEsV0FBQXlHLFVBQUEsQ0FBQXhHLFlBQUEsd0JBQUF3RyxVQUFBLEVBQUFBLFVBQUEsQ0FBQXZHLFFBQUEsU0FBQWxCLE1BQUEsQ0FBQUssY0FBQSxDQUFBa0gsTUFBQSxFQUFBRyxjQUFBLENBQUFELFVBQUEsQ0FBQWpCLEdBQUEsR0FBQWlCLFVBQUE7QUFBQSxTQUFBRSxhQUFBTixXQUFBLEVBQUFPLFVBQUEsRUFBQUMsV0FBQSxRQUFBRCxVQUFBLEVBQUFOLGlCQUFBLENBQUFELFdBQUEsQ0FBQXBILFNBQUEsRUFBQTJILFVBQUEsT0FBQUMsV0FBQSxFQUFBUCxpQkFBQSxDQUFBRCxXQUFBLEVBQUFRLFdBQUEsR0FBQTdILE1BQUEsQ0FBQUssY0FBQSxDQUFBZ0gsV0FBQSxpQkFBQW5HLFFBQUEsbUJBQUFtRyxXQUFBO0FBQUEsU0FBQUssZUFBQTVILENBQUEsUUFBQVMsQ0FBQSxHQUFBdUgsWUFBQSxDQUFBaEksQ0FBQSxnQ0FBQWdELE9BQUEsQ0FBQXZDLENBQUEsSUFBQUEsQ0FBQSxHQUFBd0gsTUFBQSxDQUFBeEgsQ0FBQTtBQUFBLFNBQUF1SCxhQUFBaEksQ0FBQSxFQUFBQyxDQUFBLG9CQUFBK0MsT0FBQSxDQUFBaEQsQ0FBQSxNQUFBQSxDQUFBLFNBQUFBLENBQUEsTUFBQUQsQ0FBQSxHQUFBQyxDQUFBLENBQUFVLE1BQUEsQ0FBQXdILFdBQUEsa0JBQUFuSSxDQUFBLFFBQUFVLENBQUEsR0FBQVYsQ0FBQSxDQUFBOEIsSUFBQSxDQUFBN0IsQ0FBQSxFQUFBQyxDQUFBLGdDQUFBK0MsT0FBQSxDQUFBdkMsQ0FBQSxVQUFBQSxDQUFBLFlBQUFxRCxTQUFBLHlFQUFBN0QsQ0FBQSxHQUFBZ0ksTUFBQSxHQUFBRSxNQUFBLEVBQUFuSSxDQUFBO0FBQ0E7QUFBQSxJQUNNb0ksVUFBVTtFQUNaO0VBQ0EsU0FBQUEsV0FBQSxFQUFjO0lBQUFmLGVBQUEsT0FBQWUsVUFBQTtJQUNWO0lBQ0EsSUFBSSxDQUFDQyxHQUFHLEdBQUcsSUFBSTtJQUNmO0lBQ0EsSUFBSSxDQUFDQyxTQUFTLEdBQUcsRUFBRTtJQUNuQjtJQUNBLElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7SUFDakI7SUFDQSxJQUFJLENBQUNDLG1CQUFtQixHQUFHLElBQUk7SUFDL0I7SUFDQSxJQUFJLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0lBQ3BCO0lBQ0EsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3pCO0lBQ0EsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ3ZCOztJQUVBLElBQUksQ0FBQ0Msa0JBQWtCLENBQUMsQ0FBQztJQUN6QjtFQUdKOztFQUdBO0VBQUFmLFlBQUEsQ0FBQU8sVUFBQTtJQUFBMUIsR0FBQTtJQUFBbEcsS0FBQSxFQUNBLFNBQUFpSSxjQUFBLEVBQWdCO01BQUEsSUFBQUksS0FBQTtNQUNaO01BQ0EsSUFBSSxDQUFDLElBQUksQ0FBQ1IsR0FBRyxFQUFFO1FBQ1g7UUFDQSxJQUFNUyxXQUFXLEdBQUcsSUFBSTtRQUN4QjtRQUNBLElBQUksQ0FBQ1QsR0FBRyxHQUFHVSxDQUFDLENBQUNWLEdBQUcsQ0FBQyxLQUFLLEVBQUU7VUFDcEJXLFFBQVEsRUFBRUQsQ0FBQyxDQUFDRSxNQUFNLENBQUMsQ0FBQztVQUNwQjtVQUNBQyxPQUFPLEVBQUVKLFdBQVc7VUFDcEI7VUFDQUssT0FBTyxFQUFFO1FBQ2IsQ0FBQyxDQUFDLENBQUNDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRU4sV0FBVyxDQUFDO1FBQy9CO1FBQ0EsSUFBTU8sUUFBUSxHQUFHLDhCQUE4QjtRQUMvQztRQUNBLElBQU1DLE1BQU0sR0FBRyxDQUNYLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFDUixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FDVDtRQUNEO1FBQ0FQLENBQUMsQ0FBQ1EsWUFBWSxDQUFDRixRQUFRLEVBQUVDLE1BQU0sQ0FBQyxDQUFDRSxLQUFLLENBQUMsSUFBSSxDQUFDbkIsR0FBRyxDQUFDO1FBQ2hEO1FBQ0EsSUFBSSxDQUFDQSxHQUFHLENBQUNvQixZQUFZLENBQUNILE1BQU0sQ0FBQztRQUM3QjtRQUNBLElBQUksQ0FBQ2pCLEdBQUcsQ0FBQ3FCLE9BQU8sQ0FBQ0Msa0JBQWtCLEdBQUcsR0FBRztRQUN6QztRQUNBLElBQUksQ0FBQ3RCLEdBQUcsQ0FBQ3VCLEVBQUUsQ0FBQyxTQUFTLEVBQUUsWUFBTTtVQUN6QixJQUFNQyxXQUFXLEdBQUdoQixLQUFJLENBQUNSLEdBQUcsQ0FBQ3lCLE9BQU8sQ0FBQyxDQUFDO1VBQ3RDLElBQUlELFdBQVcsR0FBR2YsV0FBVyxFQUFFO1lBQzNCRCxLQUFJLENBQUNSLEdBQUcsQ0FBQzBCLE9BQU8sQ0FBQ2pCLFdBQVcsQ0FBQztVQUNqQztRQUNKLENBQUMsQ0FBQztRQUNGO1FBQ0EsSUFBSSxDQUFDVCxHQUFHLENBQUN1QixFQUFFLENBQUMsT0FBTyxFQUFFLFVBQUM3SixDQUFDLEVBQUs7VUFDeEJpSyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxzQkFBc0IsRUFBRWxLLENBQUMsQ0FBQ21LLE1BQU0sQ0FBQztRQUNqRCxDQUFDLENBQUM7TUFDTjtJQUNKO0lBQ0E7RUFBQTtJQUFBeEQsR0FBQTtJQUFBbEcsS0FBQTtNQUFBLElBQUEySixtQkFBQSxHQUFBdEQsaUJBQUEsZUFBQS9HLG1CQUFBLEdBQUFvRixJQUFBLENBQ0EsU0FBQWtGLFFBQUE7UUFBQSxJQUFBQyxRQUFBLEVBQUFDLElBQUE7UUFBQSxPQUFBeEssbUJBQUEsR0FBQXVCLElBQUEsVUFBQWtKLFNBQUFDLFFBQUE7VUFBQSxrQkFBQUEsUUFBQSxDQUFBN0UsSUFBQSxHQUFBNkUsUUFBQSxDQUFBeEcsSUFBQTtZQUFBO2NBQUF3RyxRQUFBLENBQUE3RSxJQUFBO2NBQUE2RSxRQUFBLENBQUF4RyxJQUFBO2NBQUEsT0FFK0J5RyxLQUFLLENBQUMsaUNBQWlDLENBQUM7WUFBQTtjQUF6REosUUFBUSxHQUFBRyxRQUFBLENBQUE5RyxJQUFBO2NBQUEsSUFFVDJHLFFBQVEsQ0FBQ0ssRUFBRTtnQkFBQUYsUUFBQSxDQUFBeEcsSUFBQTtnQkFBQTtjQUFBO2NBQUEsTUFDTixJQUFJWCxLQUFLLFdBQUFzSCxNQUFBLENBQVdOLFFBQVEsQ0FBQ08sTUFBTSxTQUFBRCxNQUFBLENBQU1OLFFBQVEsQ0FBQ1EsVUFBVSxDQUFFLENBQUM7WUFBQTtjQUFBTCxRQUFBLENBQUF4RyxJQUFBO2NBQUEsT0FHdERxRyxRQUFRLENBQUNTLElBQUksQ0FBQyxDQUFDO1lBQUE7Y0FBNUJSLElBQUksR0FBQUUsUUFBQSxDQUFBOUcsSUFBQTtjQUNWO2NBQ0EsSUFBSSxDQUFDNEUsU0FBUyxHQUFHZ0MsSUFBSSxJQUFJLEVBQUU7Y0FDM0I7Y0FDQU4sT0FBTyxDQUFDQyxHQUFHLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDM0IsU0FBUyxDQUFDO2NBQzlDO2NBQ0E7Y0FDQSxJQUFJLENBQUN5QyxVQUFVLENBQUMsQ0FBQztjQUNqQixJQUFJLENBQUNDLDJCQUEyQixDQUFDLENBQUMsQ0FBQyxDQUFDO2NBQ3BDO2NBQUFSLFFBQUEsQ0FBQXhHLElBQUE7Y0FBQTtZQUFBO2NBQUF3RyxRQUFBLENBQUE3RSxJQUFBO2NBQUE2RSxRQUFBLENBQUFTLEVBQUEsR0FBQVQsUUFBQTtjQUVBUixPQUFPLENBQUNwRCxLQUFLLENBQUMsZ0NBQWdDLEVBQUE0RCxRQUFBLENBQUFTLEVBQU8sQ0FBQztZQUFDO1lBQUE7Y0FBQSxPQUFBVCxRQUFBLENBQUExRSxJQUFBO1VBQUE7UUFBQSxHQUFBc0UsT0FBQTtNQUFBLENBRTlEO01BQUEsU0FBQTFCLG1CQUFBO1FBQUEsT0FBQXlCLG1CQUFBLENBQUFqRCxLQUFBLE9BQUFELFNBQUE7TUFBQTtNQUFBLE9BQUF5QixrQkFBQTtJQUFBLElBRUQ7RUFBQTtJQUFBaEMsR0FBQTtJQUFBbEcsS0FBQSxFQUVBLFNBQUF1SyxXQUFBLEVBQWE7TUFBQSxJQUFBRyxNQUFBO01BQ1Q7TUFDQSxJQUFJLENBQUM1QyxTQUFTLENBQUMxRixPQUFPLENBQUMsVUFBQ3VJLFFBQVEsRUFBRUMsS0FBSyxFQUFLO1FBQ3hDO1FBQ0EsSUFBUUMsTUFBTSxHQUFtQkYsUUFBUSxDQUFqQ0UsTUFBTTtVQUFFQyxNQUFNLEdBQVdILFFBQVEsQ0FBekJHLE1BQU07VUFBRTNKLElBQUksR0FBS3dKLFFBQVEsQ0FBakJ4SixJQUFJO1FBQzVCO1FBQ0FxSSxPQUFPLENBQUNDLEdBQUcsQ0FBQyxlQUFlLEVBQUVtQixLQUFLLENBQUM7UUFDbkM7UUFDQSxJQUFNRyxNQUFNLEdBQUd4QyxDQUFDLENBQUN3QyxNQUFNLENBQUMsQ0FBQ0QsTUFBTSxFQUFFRCxNQUFNLENBQUMsRUFBRTtVQUN0QztVQUNBRyxJQUFJLEVBQUVOLE1BQUksQ0FBQ08sVUFBVSxDQUFDOUosSUFBSTtVQUMxQjtRQUNKLENBQUMsQ0FBQyxDQUFDNkgsS0FBSyxDQUFDMEIsTUFBSSxDQUFDN0MsR0FBRyxDQUFDLENBQ2J1QixFQUFFLENBQUMsT0FBTyxFQUFFO1VBQUEsT0FBTXNCLE1BQUksQ0FBQ1EsYUFBYSxDQUFDUCxRQUFRLEVBQUVDLEtBQUssQ0FBQztRQUFBLEVBQUM7O1FBRTNEO1FBQ0FHLE1BQU0sQ0FBQ0ksV0FBVyxHQUFHUCxLQUFLO1FBQzFCO1FBQ0FGLE1BQUksQ0FBQzNDLE9BQU8sQ0FBQy9ELElBQUksQ0FBQytHLE1BQU0sQ0FBQztNQUM3QixDQUFDLENBQUM7SUFDTjs7SUFFRDtJQUNGO0VBQUE7SUFBQTdFLEdBQUE7SUFBQWxHLEtBQUEsRUFDRyxTQUFBa0wsY0FBY1AsUUFBUSxFQUFFQyxLQUFLLEVBQUU7TUFBQSxJQUFBUSxNQUFBO01BRTVCO01BQ0MsSUFBUUMsSUFBSSxHQUFpRVYsUUFBUSxDQUE3RVUsSUFBSTtRQUFFbEssSUFBSSxHQUEyRHdKLFFBQVEsQ0FBdkV4SixJQUFJO1FBQUVtSyxLQUFLLEdBQW9EWCxRQUFRLENBQWpFVyxLQUFLO1FBQUVDLEtBQUssR0FBNkNaLFFBQVEsQ0FBMURZLEtBQUs7UUFBRUMsV0FBVyxHQUFnQ2IsUUFBUSxDQUFuRGEsV0FBVztRQUFFQyxPQUFPLEdBQXVCZCxRQUFRLENBQXRDYyxPQUFPO1FBQUVDLE9BQU8sR0FBY2YsUUFBUSxDQUE3QmUsT0FBTztRQUFFQyxPQUFPLEdBQUtoQixRQUFRLENBQXBCZ0IsT0FBTztNQUN4RTtNQUNBLElBQU1DLFVBQVUsR0FBR0MsUUFBUSxDQUFDQyxjQUFjLENBQUMsYUFBYSxDQUFDO01BQ3pEO01BQ0F0QyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxVQUFVLEVBQUVpQyxPQUFPLENBQUM7TUFDaEM7TUFDQTtNQUNBRSxVQUFVLENBQUNHLFNBQVMsaUZBQUE1QixNQUFBLENBQzZDa0IsSUFBSSxvQ0FBQWxCLE1BQUEsQ0FDckRtQixLQUFLLGVBQUFuQixNQUFBLENBQVVrQixJQUFJLGlHQUFBbEIsTUFBQSxDQUMyQ3FCLFdBQVcsd0xBQUFyQixNQUFBLENBR1ZoSixJQUFJLHlHQUFBZ0osTUFBQSxDQUNFb0IsS0FBSyxDQUFDUyxVQUFVLHVHQUFBN0IsTUFBQSxDQUNsQm9CLEtBQUssQ0FBQ1UsUUFBUSw0S0FBQTlCLE1BQUEsQ0FHakJvQixLQUFLLENBQUNXLEtBQUsscUdBQUEvQixNQUFBLENBQ1ZvQixLQUFLLENBQUNZLEtBQUssdUdBQUFoQyxNQUFBLENBQ1RvQixLQUFLLENBQUNhLFFBQVEsNktBQUFqQyxNQUFBLENBR2hCb0IsS0FBSyxDQUFDYyxVQUFVLG1HQUFBbEMsTUFBQSxDQUNsQm9CLEtBQUssQ0FBQ2UsSUFBSSxvR0FBQW5DLE1BQUEsQ0FDVG9CLEtBQUssQ0FBQ2dCLFVBQVUsOEpBQUFwQyxNQUFBLENBSXBDUyxLQUFLLHNIQUFBVCxNQUFBLENBQ2VTLEtBQUssK0NBRXBGO01BQ0Q7O01BRUE7TUFDQTtNQUNBLElBQUlhLE9BQU8sRUFBRTtRQUNUZSxVQUFVLENBQUMsWUFBTTtVQUNicEIsTUFBSSxDQUFDakQsZ0JBQWdCLENBQUNzRCxPQUFPLEVBQUViLEtBQUssQ0FBQztRQUN6QyxDQUFDLEVBQUUsR0FBRyxDQUFDO01BQ1g7TUFDQTtNQUNBLElBQUljLE9BQU8sRUFBRTtRQUNULElBQUksQ0FBQ3RELGtCQUFrQixDQUFDc0QsT0FBTyxFQUFFZCxLQUFLLENBQUM7TUFDM0M7O01BRUE7O01BRUE7TUFDQTtNQUNBOztNQUVBO01BQ0FnQixVQUFVLENBQUNhLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLE1BQU07SUFDckM7O0lBRUE7RUFBQTtJQUFBeEcsR0FBQTtJQUFBbEcsS0FBQSxFQUVBLFNBQUFpTCxXQUFXOUosSUFBSSxFQUFFO01BQ2I7TUFDQTtNQUNBO01BQ0EsSUFBSXdMLE9BQU87TUFDWCxJQUFJQyxRQUFRLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDOztNQUd2QjtNQUNBLFFBQVF6TCxJQUFJO1FBQ1IsS0FBSyxNQUFNO1VBQ1B3TCxPQUFPLEdBQUcsc0JBQXNCO1VBQ2hDO1FBQ0osS0FBSyxRQUFRO1VBQ1RBLE9BQU8sR0FBRyx3QkFBd0I7VUFDbEM7UUFFSixLQUFLLFFBQVE7VUFDVEEsT0FBTyxHQUFHLHdCQUF3QjtVQUNsQztRQUVKLEtBQUssT0FBTztVQUNSQSxPQUFPLEdBQUcsdUJBQXVCO1VBQ2pDO1FBRUEsS0FBSyxNQUFNO1VBQ1hBLE9BQU8sR0FBRyxzQkFBc0I7VUFDaEM7UUFFSixLQUFLLFlBQVk7VUFDYkEsT0FBTyxHQUFHLDRCQUE0QjtVQUN0QztRQUVKLEtBQUssZUFBZTtVQUNoQkEsT0FBTyxHQUFHLCtCQUErQjtVQUN6QztRQUVKLEtBQUssT0FBTztVQUNSQSxPQUFPLEdBQUcsdUJBQXVCO1VBQ2pDO1FBRUo7VUFDSUEsT0FBTyxHQUFHLHVCQUF1QjtVQUNqQztNQUNSOztNQUVBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQSxPQUFPcEUsQ0FBQyxDQUFDeUMsSUFBSSxDQUFDO1FBQ1YyQixPQUFPLEVBQVBBLE9BQU87UUFDUEMsUUFBUSxFQUFSQSxRQUFRO1FBQ1JDLFVBQVUsRUFBRSxDQUFDRCxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlDRSxXQUFXLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0YsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsQztRQUNBekwsSUFBSSxFQUFFQTtNQUVWLENBQUMsQ0FBQztJQUNOOztJQU9BO0lBQ0E7RUFBQTtJQUFBK0UsR0FBQTtJQUFBbEcsS0FBQSxFQUNBLFNBQUFtSSxpQkFBaUJzRCxPQUFPLEVBQUViLEtBQUssRUFBRztNQUM5QjtNQUNBO01BQ0E7TUFDQSxJQUFNbUMsUUFBUSxrQkFBQTVDLE1BQUEsQ0FBa0JTLEtBQUssQ0FBRTtNQUN2QyxJQUFNbkMsTUFBTSxHQUFHb0QsUUFBUSxDQUFDQyxjQUFjLENBQUNpQixRQUFRLENBQUM7O01BRWhEO01BQ0EsSUFBSSxDQUFDdEUsTUFBTSxFQUFFO1FBQ1Q7UUFDQTtNQUNKO01BRUEsSUFBTXVFLEdBQUcsR0FBR3ZFLE1BQU0sQ0FBQ3dFLFVBQVUsQ0FBQyxJQUFJLENBQUM7TUFFbkMsSUFBSSxPQUFPQyxLQUFLLEtBQUssV0FBVyxFQUFFO1FBQzlCMUQsT0FBTyxDQUFDcEQsS0FBSyxDQUFDLHdDQUF3QyxDQUFDO1FBQ3ZEO01BQ0o7TUFFQSxJQUFJLENBQUNxRixPQUFPLElBQUkvTCxNQUFNLENBQUNzRixJQUFJLENBQUN5RyxPQUFPLENBQUMsQ0FBQ3BILE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDL0NtRixPQUFPLENBQUNwRCxLQUFLLENBQUMscUNBQXFDLENBQUM7UUFDcEQ7TUFDSjtNQUVBOEcsS0FBSyxDQUFDQyxRQUFRLENBQUNDLE1BQU0sQ0FBQ0MsU0FBUyxHQUFHLEtBQUs7TUFDdkM7TUFDQTtNQUNBLElBQU1DLFlBQVksR0FBRzVOLE1BQU0sQ0FBQ3NGLElBQUksQ0FBQ3lHLE9BQU8sQ0FBQztNQUN6QyxJQUFNOEIsYUFBYSxHQUFHN04sTUFBTSxDQUFDdUMsTUFBTSxDQUFDd0osT0FBTyxDQUFDOztNQUU1QztNQUNBLElBQUl5QixLQUFLLENBQUNGLEdBQUcsRUFBRTtRQUNYN0wsSUFBSSxFQUFFLFVBQVU7UUFDaEIySSxJQUFJLEVBQUU7VUFDRjBELE1BQU0sRUFBRUYsWUFBWTtVQUNwQkcsUUFBUSxFQUFFLENBQUM7WUFDUDNELElBQUksRUFBRXlELGFBQWE7WUFDbkJHLGVBQWUsRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUM7WUFDeEVDLG9CQUFvQixFQUFFLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVM7VUFDaEYsQ0FBQztRQUNMLENBQUM7UUFDRHpFLE9BQU8sRUFBRTtVQUNMMEUsVUFBVSxFQUFFLElBQUk7VUFDaEJDLG1CQUFtQixFQUFFLEtBQUs7VUFDMUJDLGdCQUFnQixFQUFFLEVBQUU7VUFDcEJDLEtBQUssRUFBRTtZQUNIckIsT0FBTyxFQUFFLElBQUk7WUFDYnNCLElBQUksRUFBRSxvQkFBb0I7WUFDMUJDLFNBQVMsRUFBRTtVQUNmLENBQUM7VUFDREMsUUFBUSxFQUFFO1lBQ05DLE9BQU8sRUFBRSxJQUFJO1lBQ2JDLFNBQVMsRUFBRTtjQUNQO2NBQ0E7Y0FDQUMsS0FBSyxFQUFFLFNBQUFBLE1BQUNDLFdBQVcsRUFBRXhFLElBQUksRUFBSztnQkFDMUIsSUFBTXlFLE9BQU8sR0FBR3pFLElBQUksQ0FBQzJELFFBQVEsQ0FBQ2EsV0FBVyxDQUFDRSxZQUFZLENBQUM7Z0JBQ3ZELElBQU1DLEtBQUssR0FBR0YsT0FBTyxDQUFDekUsSUFBSSxDQUFDNEUsTUFBTSxDQUFDLFVBQUNDLGFBQWEsRUFBRUMsWUFBWTtrQkFBQSxPQUFLRCxhQUFhLEdBQUdDLFlBQVk7Z0JBQUEsRUFBQztnQkFDaEcsSUFBTUEsWUFBWSxHQUFHTCxPQUFPLENBQUN6RSxJQUFJLENBQUN3RSxXQUFXLENBQUMxRCxLQUFLLENBQUM7Z0JBQ3BELElBQU1pRSxVQUFVLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFHSCxZQUFZLEdBQUdILEtBQUssR0FBSSxHQUFHLEdBQUksR0FBRyxDQUFDO2dCQUNuRSxVQUFBdEUsTUFBQSxDQUFVTCxJQUFJLENBQUMwRCxNQUFNLENBQUNjLFdBQVcsQ0FBQzFELEtBQUssQ0FBQyxRQUFBVCxNQUFBLENBQUswRSxVQUFVO2NBQzNEO1lBQ0o7VUFDSixDQUFDO1VBQ0RHLE1BQU0sRUFBRTtZQUNKeEIsTUFBTSxFQUFFO2NBQ0pTLFNBQVMsRUFBRTtZQUNmO1VBQ0osQ0FBQztVQUNEZ0IsTUFBTSxFQUFFO1lBQ0pDLE9BQU8sRUFBRTtjQUNMQyxJQUFJLEVBQUUsQ0FBQztjQUNQQyxLQUFLLEVBQUUsQ0FBQztjQUNSQyxHQUFHLEVBQUUsQ0FBQztjQUNOQyxNQUFNLEVBQUU7WUFDWjtVQUNKO1FBQ0o7TUFDSixDQUFDLENBQUM7SUFDTjs7SUFFQTtFQUFBO0lBQUFwSixHQUFBO0lBQUFsRyxLQUFBLEVBRUEsU0FBQW9JLG1CQUFtQnNELE9BQU8sRUFBRWQsS0FBSyxFQUFFO01BQy9CO01BQ0EsSUFBTW1DLFFBQVEsb0JBQUE1QyxNQUFBLENBQW9CUyxLQUFLLENBQUU7TUFDekMsSUFBTW5DLE1BQU0sR0FBR29ELFFBQVEsQ0FBQ0MsY0FBYyxDQUFDaUIsUUFBUSxDQUFDO01BQ2hEO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQSxJQUFJLENBQUN0RSxNQUFNLEVBQUU7UUFDVDtRQUNBO01BQ0o7TUFFQSxJQUFNdUUsR0FBRyxHQUFHdkUsTUFBTSxDQUFDd0UsVUFBVSxDQUFDLElBQUksQ0FBQztNQUVuQyxJQUFJLE9BQU9DLEtBQUssS0FBSyxXQUFXLEVBQUU7UUFDOUIxRCxPQUFPLENBQUNwRCxLQUFLLENBQUMsd0NBQXdDLENBQUM7UUFDdkQ7TUFDSjtNQUVBLElBQUksQ0FBQ3NGLE9BQU8sSUFBSWhNLE1BQU0sQ0FBQ3NGLElBQUksQ0FBQzBHLE9BQU8sQ0FBQyxDQUFDckgsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUMvQ21GLE9BQU8sQ0FBQ3BELEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQztRQUNwRDtNQUNKO01BRUE4RyxLQUFLLENBQUNDLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDQyxTQUFTLEdBQUcsS0FBSztNQUV2QyxJQUFNa0MsVUFBVSxHQUFHN1AsTUFBTSxDQUFDc0YsSUFBSSxDQUFDMEcsT0FBTyxDQUFDO01BQ3ZDLElBQU04RCxXQUFXLEdBQUc5UCxNQUFNLENBQUN1QyxNQUFNLENBQUN5SixPQUFPLENBQUM7TUFDMUNsQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyxVQUFVLEVBQUVpQyxPQUFPLENBQUM7TUFFaEMsSUFBSXdCLEtBQUssQ0FBQ0YsR0FBRyxFQUFFO1FBQ1g3TCxJQUFJLEVBQUUsS0FBSztRQUNYMkksSUFBSSxFQUFFO1VBQ0YwRCxNQUFNLEVBQUUrQixVQUFVO1VBQ2xCOUIsUUFBUSxFQUFFLENBQUM7WUFDUDNELElBQUksRUFBRTBGLFdBQVc7WUFDakI5QixlQUFlLEVBQUUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDO1lBQ3hFQyxvQkFBb0IsRUFBRSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTO1VBQ2hGLENBQUM7UUFDTCxDQUFDO1FBQ0R6RSxPQUFPLEVBQUU7VUFDTDBFLFVBQVUsRUFBRSxJQUFJO1VBQ2hCQyxtQkFBbUIsRUFBRSxLQUFLO1VBQzFCQyxnQkFBZ0IsRUFBRSxFQUFFO1VBQ3BCQyxLQUFLLEVBQUU7WUFDSHJCLE9BQU8sRUFBRSxJQUFJO1lBQ2JzQixJQUFJLEVBQUUsb0JBQW9CO1lBQzFCQyxTQUFTLEVBQUU7VUFDZixDQUFDO1VBQ0RDLFFBQVEsRUFBRTtZQUNOQyxPQUFPLEVBQUUsSUFBSTtZQUNiQyxTQUFTLEVBQUU7Y0FDUEMsS0FBSyxFQUFFLFNBQUFBLE1BQUNDLFdBQVcsRUFBRXhFLElBQUksRUFBSztnQkFDMUIsSUFBTXlFLE9BQU8sR0FBR3pFLElBQUksQ0FBQzJELFFBQVEsQ0FBQ2EsV0FBVyxDQUFDRSxZQUFZLENBQUM7Z0JBQ3ZELElBQU1DLEtBQUssR0FBR0YsT0FBTyxDQUFDekUsSUFBSSxDQUFDNEUsTUFBTSxDQUFDLFVBQUNDLGFBQWEsRUFBRUMsWUFBWTtrQkFBQSxPQUFLRCxhQUFhLEdBQUdDLFlBQVk7Z0JBQUEsRUFBQztnQkFDaEcsSUFBTUEsWUFBWSxHQUFHTCxPQUFPLENBQUN6RSxJQUFJLENBQUN3RSxXQUFXLENBQUMxRCxLQUFLLENBQUM7Z0JBQ3BELElBQU1pRSxVQUFVLEdBQUdDLElBQUksQ0FBQ0MsS0FBSyxDQUFHSCxZQUFZLEdBQUdILEtBQUssR0FBSSxHQUFHLEdBQUksR0FBRyxDQUFDO2dCQUNuRSxVQUFBdEUsTUFBQSxDQUFVTCxJQUFJLENBQUMwRCxNQUFNLENBQUNjLFdBQVcsQ0FBQzFELEtBQUssQ0FBQyxRQUFBVCxNQUFBLENBQUswRSxVQUFVO2NBQzNEO1lBQ0o7VUFDSixDQUFDO1VBQ0RHLE1BQU0sRUFBRTtZQUNKeEIsTUFBTSxFQUFFO2NBQ0pTLFNBQVMsRUFBRTtZQUNmO1VBQ0osQ0FBQztVQUNEZ0IsTUFBTSxFQUFFO1lBQ0pDLE9BQU8sRUFBRTtjQUNMQyxJQUFJLEVBQUUsQ0FBQztjQUNQQyxLQUFLLEVBQUUsQ0FBQztjQUNSQyxHQUFHLEVBQUUsQ0FBQztjQUNOQyxNQUFNLEVBQUU7WUFDWjtVQUNKO1FBQ0o7TUFDSixDQUFDLENBQUM7SUFDTjs7SUFHQTs7SUFHQTs7SUFFQTs7SUFFQTtJQUNBOztJQUVBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTs7SUFFQTs7SUFFQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7O0lBR0E7RUFBQTtJQUFBcEosR0FBQTtJQUFBbEcsS0FBQSxFQUVBLFNBQUF3Syw0QkFBQSxFQUE4QjtNQUFBLElBQUFpRixNQUFBO01BQzFCO01BQ0EsSUFBTUMsWUFBWSxHQUFHN0QsUUFBUSxDQUFDQyxjQUFjLENBQUMsZUFBZSxDQUFDO01BQzdEO01BQ0E0RCxZQUFZLENBQUMzRCxTQUFTLGNBQVk7O01BRWxDO01BQ0EsSUFBTTRELFdBQVcsR0FBQUMsa0JBQUEsQ0FBTyxJQUFJQyxHQUFHLENBQUMsSUFBSSxDQUFDL0gsU0FBUyxDQUFDRCxHQUFHLENBQUMsVUFBQThDLFFBQVE7UUFBQSxPQUFJQSxRQUFRLENBQUN4SixJQUFJO01BQUEsRUFBQyxDQUFDLENBQUM7O01BRS9FO01BQ0F3TyxXQUFXLENBQUN2TixPQUFPLENBQUMsVUFBQWpCLElBQUksRUFBSTtRQUN4QjtRQUNBLElBQU0yTyxNQUFNLEdBQUdqRSxRQUFRLENBQUNrRSxhQUFhLENBQUMsUUFBUSxDQUFDO1FBQy9DO1FBQ0FELE1BQU0sQ0FBQ0UsV0FBVyxHQUFHN08sSUFBSTtRQUN6QjtRQUNBMk8sTUFBTSxDQUFDRyxTQUFTLENBQUNDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQztRQUN2QztRQUNBSixNQUFNLENBQUNLLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtVQUFBLE9BQU1WLE1BQUksQ0FBQ1csd0JBQXdCLENBQUNqUCxJQUFJLENBQUM7UUFBQSxFQUFDO1FBQzNFO1FBQ0F1TyxZQUFZLENBQUNXLFdBQVcsQ0FBQ1AsTUFBTSxDQUFDO01BQ3BDLENBQUMsQ0FBQztJQUNOOztJQUVBO0VBQUE7SUFBQTVKLEdBQUE7SUFBQWxHLEtBQUEsRUFFQSxTQUFBb1EseUJBQXlCalAsSUFBSSxFQUFFO01BQUEsSUFBQW1QLE1BQUE7TUFDM0I7TUFDQSxJQUFJLENBQUN2SSxPQUFPLENBQUMzRixPQUFPLENBQUMsVUFBQTJJLE1BQU0sRUFBSTtRQUMzQjtRQUNBLElBQUlBLE1BQU0sQ0FBQzdCLE9BQU8sSUFBSTZCLE1BQU0sQ0FBQzdCLE9BQU8sQ0FBQzhCLElBQUksSUFBSUQsTUFBTSxDQUFDN0IsT0FBTyxDQUFDOEIsSUFBSSxDQUFDOUIsT0FBTyxFQUFFO1VBQ3RFLElBQU1xSCxZQUFZLEdBQUd4RixNQUFNLENBQUM3QixPQUFPLENBQUM4QixJQUFJLENBQUM5QixPQUFPLENBQUMvSCxJQUFJO1VBQ3JEO1VBQ0EsSUFBSW9QLFlBQVksS0FBS3BQLElBQUksRUFBRTtZQUN2QixJQUFJbVAsTUFBSSxDQUFDekksR0FBRyxDQUFDMkksUUFBUSxDQUFDekYsTUFBTSxDQUFDLEVBQUU7Y0FDM0J1RixNQUFJLENBQUN6SSxHQUFHLENBQUM0SSxXQUFXLENBQUMxRixNQUFNLENBQUM7WUFDaEMsQ0FBQyxNQUFNO2NBQ0h1RixNQUFJLENBQUN6SSxHQUFHLENBQUM2SSxRQUFRLENBQUMzRixNQUFNLENBQUM7WUFDN0I7VUFDSixDQUFDLE1BQU07WUFDSDtZQUNBLElBQUksQ0FBQ3VGLE1BQUksQ0FBQ3pJLEdBQUcsQ0FBQzJJLFFBQVEsQ0FBQ3pGLE1BQU0sQ0FBQyxFQUFFO2NBQzVCdUYsTUFBSSxDQUFDekksR0FBRyxDQUFDNkksUUFBUSxDQUFDM0YsTUFBTSxDQUFDO1lBQzdCO1VBQ0o7VUFDQTtRQUNKLENBQUMsTUFBTTtVQUNIdkIsT0FBTyxDQUFDcEQsS0FBSyxDQUFDLG9EQUFvRCxDQUFDO1FBQ3ZFO01BQ0osQ0FBQyxDQUFDO0lBQ047RUFBQztFQUFBLE9BQUF3QixVQUFBO0FBQUEsS0FHTDtBQUNBLElBQU0rSSxVQUFVLEdBQUcsSUFBSS9JLFVBQVUsQ0FBQyxDQUFDLEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS13ZWJwYWNrLXByb2plY3QvLi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbi8vLyBjbGFzcyBtZXRob2QgRmFudGFzeU1hcCB0aGF0IGluY2x1ZWQgYWxsIG1ldGhvZHMgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBhcHBsaWNhdGlvblxuY2xhc3MgRmFudGFzeU1hcCB7XG4gICAgLy8gcmVsYXRpdmUgY29uc3RydWN0b3IgY2xhc3NcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy90aGlzLm1hcCBpcyBpbiBjaGFyZ2Ugb2Ygc2V0dGluZyB1cCB0aGUgYmFzaWMgbWFwLiBcbiAgICAgICAgdGhpcy5tYXAgPSBudWxsO1xuICAgICAgICAvL3RoaXMubG9jYXRpb25zIGlzIGluIGNoYXJnZSBvZiBzZXR0aW5nIHVwIHRoZSBsb2NhdGlvbnMgZm91bmQgaW4gdGhlIG1hcCwgZm91bmQgYnkgY29ubmVjdGluZyB0byB0aGUgVVJMIGZyb20gdGhlIGxvY2F0aW9ucy5KU09OIEZJTEVcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMgPSBbXTtcbiAgICAgICAgLy90aGlzLm1hcmtlcnMgaXMgaW4gY2hhcmdlIG9mIHNldHRpbmcgdXAgdGhlIHRvZ2dsZSBNYXJrZXJzIG9mIHRoZSBhcHBsaWNhdGlvbnMuIFxuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgLy90aGlzIGlzIGlzIGNoYXJnZSBvZiBtYWtpbmcgc3VyZSB0aGF0IHRoZSBtYXJrZXJzIGFyZSB2aXNpYmxlIGJ5IGRlZnVhbHQgd2hlbiB0aGUgbWFwIHN0YXJ0cy4gXG4gICAgICAgIHRoaXMuYnJpZGdlTWFya2VyVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIC8vdGhpcyBhY3RpdmF0ZXMgdGhlIGluaXRpYWxpemVNYXAgbWV0aG9kXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU1hcCgpO1xuICAgICAgICAvL3RoaXMgYWN0aXZhdGVzIHRoZSBmZXRjaExvY2F0aW9uc0RhdGEgdGhhdCBkcmF3cyBmcm9tIHRoZSBsb2NhdGlvbnMuanNvbiBkYXRhLlxuICAgICAgICB0aGlzLmZldGNoTG9jYXRpb25zRGF0YSgpO1xuICAgICAgICAvL3RoaXMgaXMgZm9yIGNyZWF0aW5nIHRoZSBkb251dENoYXJ0IHRoYXQgd2lsbCB1c2UgY2hhcnQuanMgdG8gZ2V0IHRoZSBzcGVjaWVzIGRhdGEgZnJvbSB0aGUgbG9jYXRpb25zLmpzb25cbiAgICAgICAgdGhpcy5jcmVhdGVEb251dENoYXJ0KCk7XG4gICAgICAgIC8vdGhpcyBpcyBmb3IgY3JlYXRpbmcgdGhlIGNsYXNzZXMgY2hhcnQgdGhhdCB3aWxsIHVzZSBjaGFydC5qcyB0byBnZXQgdGhlIGNsYXNzZXMgZGF0YSBmcm9tIHRoZSBsb2NhdGlvbnMuXG5cbiAgICAgICAgdGhpcy5jcmVhdGVDbGFzc2VzQ2hhcnQoKTtcbiAgICAgICAgLy8gdGhpcy5jcmVhdGVGYWN0aW9uKCk7ICAtIHdhbnRlZCB0byBpbXBsZW1lbnQgYSB0aGlyZCBncmFwaCBkaXNwbGF5aW5nIHRoZSBmYWN0aW9ucywgYnV0IGNvdWxkIG5vdCBpbXBsaW1lbnQgd2l0aCBnaXZlbiB0aW1lXG4gICAgICAgIFxuXG4gICAgfVxuXG5cbiAgICAvL2luaXRpYWxpemVNYXAgbWV0aG9kIGlzIGluIGNoYXJnZSBvZiBnZXR0aW5nIHRoZSBiYXNlIG1hcCBpbmZvcm1hdGlvblxuICAgIGluaXRpYWxpemVNYXAoKSB7XG4gICAgICAgIC8vc2V0IHVwIHRoZSBtYXAgY29ubmVjdGlvblxuICAgICAgICBpZiAoIXRoaXMubWFwKSB7XG4gICAgICAgICAgICAvLyBzZXQgdXAgaXRzIHN0YXJ0aW5nIHpvb20gbGV2ZWwsIHRha2VuIGZyb20gbGVhZmxldC5qcyBjb25maWd1cmF0aW9uXG4gICAgICAgICAgICBjb25zdCBpbml0aWFsWm9vbSA9IDEwLjk7XG4gICAgICAgICAgICAvL3NldCB1cCB0aGUgbWFwJ3MgY2FudmFzIFxuICAgICAgICAgICAgdGhpcy5tYXAgPSBMLm1hcCgnbWFwJywge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBMLmNhbnZhcygpLFxuICAgICAgICAgICAgICAgIC8vc2V0IGl0cyBtaW56b29tIGxldmVsIHRvIHRoZSBleGFjdCBzYW1lIHpvb20gbGV2ZWwgYXMgaXRzIHN0YXJ0aW5nIGludGlhbFpvb21cbiAgICAgICAgICAgICAgICBtaW5ab29tOiBpbml0aWFsWm9vbSxcbiAgICAgICAgICAgICAgICAvL3NldCBtYXggem9vbSB0byAxOFxuICAgICAgICAgICAgICAgIG1heFpvb206IDE4LFxuICAgICAgICAgICAgfSkuc2V0VmlldyhbMCwgMF0sIGluaXRpYWxab29tKTtcbiAgICAgICAgICAgIC8vY29ubmVjdCB0aGUgaW1hZ2VVcmwgdG8gdGhlIG1hcCBmaWxlIGFzIGl0cyBiYWNrZ3JvdW5kXG4gICAgICAgICAgICBjb25zdCBpbWFnZVVybCA9ICcuL2Fzc2V0cy9zaXJ1a3N2YWxsZXltYXAucG5nJztcbiAgICAgICAgICAgIC8vIHNldCBpdHMgYm91bmQncywgc28gdG8gYXZvaWQgYSB0ZXJyaWJsZSB3aGl0ZSBzY3JlZW4gb3V0c2lkZSB0aGUgbWFwIHNpemVcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IFtcbiAgICAgICAgICAgICAgICBbLTEsIC0xXSxcbiAgICAgICAgICAgICAgICBbMSwgMV1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvL3Rha2UgdGhlIGltYWdlVXJsIGFuZCBpdHMgZGVmaW5lZCBib3VuZHMgYW5kIGFkZCBpdCB0byB0aGUgdGhpcy5tYXAgZm91bmQgYWJvdmUgaW4gYSBsZWFmbGV0IGltYWdlIG92ZXJsYXlcbiAgICAgICAgICAgIEwuaW1hZ2VPdmVybGF5KGltYWdlVXJsLCBib3VuZHMpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgICAgIC8vd2l0aCB0aGUgbWFwIHNldCBpcyBtYXhib3VuZHMgdG8gdGhlIHBhcmFtZXRlciBvZiBib3VuZHMgZGVmaW5lZCBhYm92ZS5cbiAgICAgICAgICAgIHRoaXMubWFwLnNldE1heEJvdW5kcyhib3VuZHMpO1xuICAgICAgICAgICAgLy9zZXQgaXRzIHZpc2Nvc2l0eVxuICAgICAgICAgICAgdGhpcy5tYXAub3B0aW9ucy5tYXhCb3VuZHNWaXNjb3NpdHkgPSAxLjA7XG4gICAgICAgICAgICAvL3NldCBhIGFkZGl0aW9uYWwgem9vbSBidXR0b25zIG9uIHRoZSBsZWZ0IHRvcCBzaWRlIG9mIHRoZSBtYXBcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCd6b29tZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Wm9vbSA8IGluaXRpYWxab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFpvb20oaW5pdGlhbFpvb20pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy91c2VkIGZvciBkZWJ1Z2dpbmcuIHVzZWQgdG8gY2xpY2sgb24gdGhlIG1hcCBhbmQgY29uc29sZS5sb2cgdGhlIGNvb3JkaW5hdGVzIGFzIHRvIHNldHVwIGEgd2F5IHRvIHNldCB0aGUgbG9jYXRpb25zLmpzb24gZGF0YSB0byByZWxldmFudCBwb2ludCBpbiB0aGUgbWFwLiAgXG4gICAgICAgICAgICB0aGlzLm1hcC5vbignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDdXJyZW50IENvb3JkaW5hdGVzOicsIGUubGF0bG5nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGEgYXN5bmMgZnVuY3Rpb24gdXNlZCB0byBmZXRjaCB0aGUgZGF0YSBmcm9tIHRoZSBsb2NhbCBob3N0LiBcbiAgICBhc3luYyBmZXRjaExvY2F0aW9uc0RhdGEoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCdodHRwOi8vbG9jYWxob3N0OjMwMDAvbG9jYXRpb25zJyk7IC8vdGhpcyBpcyBzdXBwb3NlZCB0byBiZSB0aGUgY2l0V2ViIGxvY2F0aW9uIGFkZHJlc3MgdG8gaG9zdCwgaG93ZXZlciB3YXMgbm90IGFibGUgdG8gZ2V0IGl0IHRvIGNvbm5lY3QuIFxuICAgICAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgbm90IGZvdW5kIHRoYXQgaXQgc2hvdWxkIHB1c2ggYSBlcnJvciB3aXRoIGl0cyBzdGF0dXMgaXNzdWVcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gLSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NldCBhIHZhcmlhYmxlIGRhdGEgZXF1YWwgdG8gdGhlIGF3YWl0J3MgcmVzcG9uc2UuanNvblxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIC8vdGhpcy5sb2NhdGlvbnMgdmFyaWFibGUgd2lsbCBiZSBlcXVhbCB0byB0aGUgZGF0YSB2YXJpYWJsZSBkZWZpbmVkIGFib3ZlIG9yIGEgZW1wdHkgYXJyYXkuXG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9ucyA9IGRhdGEgfHwgW107XG4gICAgICAgICAgICAvL3VzZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdpbGwgbG9nIHRoZSBsb2NhdGlvbnMgZGF0YS4gXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTG9jYXRpb25zIERhdGE6JywgdGhpcy5sb2NhdGlvbnMpO1xuICAgICAgICAgICAgLy90aGUgYWRkTWFya2VycyBtZXRob2Qgd2lsbCBiZSB1c2VkIHRvIGdldCB0aGUgYWN0dWFsIGRhdGEgZnJvbSB0aGUgbG9jYXRpb25zIGZvdW5kIGFuZCBhZGQgYSByZWxhdGl2ZSBpY29uIHRvIGl0IG9uIHRoZSBib3R0b20gdGFiKGV4cGxhaW5lZCBmdXJ0aGVyIGJlbG93KVxuICAgICAgICAgICAgLy8gYm90aCBtZXRob2RzIGJlbG93IHdpbGwgbmVlZCB0byBmaXJlIHRoZSBtb21lbnQgdGhlIGZldGNoIGxvY2F0aW9uc0RhdGEgaXMgZmlyZWQgaW4gb3JkZXIgdG8gY29ycmVjdGx5IHBhc3MgY29ycmVjdCBpY29ucyB0byB0aGUgYm90dG9tIHRhYi5cbiAgICAgICAgICAgIHRoaXMuYWRkTWFya2VycygpO1xuICAgICAgICAgICAgdGhpcy5hZGRCcmlkZ2VJY29uVG9Mb2NhdGlvbnNUYWIoKTsgLy8gQWRkIHRoZSBpY29uIHRvIHRoZSBib3R0b20gdGFiLiBcbiAgICAgICAgICAgIC8vIGEgZXJyb3IgdG8gYmUgc2V0IHVwIGlmIHRoZSBsb2NhdGlvbnMgZGF0YSBpcyBub3QgZm91bmQuIHdhcyB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLiBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGxvY2F0aW9ucyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vYWRkTWFya2VycyBtZXRob2QuIFVzZWQgdG8gZ2V0IHRoZSBleGFjdCBjb29yZGluYXRlcyBhbmQgdHlwZSBmcm9tIHRoZSBsb2NhdGlvbnMuanNvbiBkYXRhIGFuZCBwYXNzIHRob3NlIHZhbHVlcyB0byB0aGUgYm90dG9tIHRhYiwgbWFraW5nIGl0IHJlbGF0aXZlIHRvIHRoZSBpY29uIHRhYlxuXG4gICAgYWRkTWFya2VycygpIHtcbiAgICAgICAgLy9zZXQgdXAgYSBmb3IgZWFjaCBtZXRob2Qgd2l0aCBsb2NhdGlvbiBhbmQgaW5kZXggcGFzc2VkIGFzIHBhcmFtZXRlcnNcbiAgICAgICAgdGhpcy5sb2NhdGlvbnMuZm9yRWFjaCgobG9jYXRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAvL3RoZSB4Q29vcmQsIGFuZCBZQ29ycmQsIGFzIHdlbGwgYXMgdHlwZSBpcyBlcXVhbCB0byB0aGUgbG9jYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHsgWENvb3JkLCBZQ29vcmQsIHR5cGUgfSA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgLy9mb3IgdGVzdGluZyBwdXJwb3NlcyBsb2dnaW5nIHRoZSBtYXJrZXJzIGluZGV4XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTWFya2VyIGluZGV4OicsIGluZGV4KTtcbiAgICAgICAgICAgIC8vdGhlIG1hcmtlciBub3cgZXF1YWxzIHRoZSBsZWFmbGV0bWFya2VyIGF0IHRoZSBvYmplY3QgdmFsdWVzIG9mIFlDb29kIGFuZCBYQ29vcmRcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IEwubWFya2VyKFtZQ29vcmQsIFhDb29yZF0sIHtcbiAgICAgICAgICAgICAgICAvL3dpdGhpbiB0aGUgbWFya2VyIG1ldGhvZCBpY29uIGlzIGVxdWFsIHRvIHRoZSBjdXN0b21JY29uIHJlbGF0aXZlIHRvIHR5cGUgYXR0cmlidXRlIGZvdW5kIGluIHRoZSBsb2NhdGlvbnMuSnNvbiBkYXRhXG4gICAgICAgICAgICAgICAgaWNvbjogdGhpcy5jdXN0b21JY29uKHR5cGUpXG4gICAgICAgICAgICAgICAgLy9hZGQgYSBzZWNvbmQgcHJvcGVydHkgdG8gbWFya2VyIHdoY2loIGlzIGFkZFRvIHdpdGggdGhlIHBhcmFtZXRlciB0aGlzLm1hcCwgd2l0aGluIGFkZCBhIGNsaWNrIGV2ZW50IHRoYXQgd2lsbCByZXR1cm4gb25NYXJrZXJDbGljayB3aXRoIHRoZSBsb2NhdGlvbiBhbmQgaW5kZXggYXMgcGFyYW1ldGVyc1xuICAgICAgICAgICAgfSkuYWRkVG8odGhpcy5tYXApXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHRoaXMub25NYXJrZXJDbGljayhsb2NhdGlvbiwgaW5kZXgpKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZXQgbWFya2VyLl9sZWFmbGV0X2lkIGVxdWFsIHRvIHRoZSBpbmRleCBmb3VuZCBvbiB0aGUgY2xpY2suXG4gICAgICAgICAgICBtYXJrZXIuX2xlYWZsZXRfaWQgPSBpbmRleDtcbiAgICAgICAgICAgIC8vcHVzaCB0aGUgbWFya2VyIHRvIG1hcmtlci4gXG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgIC8vb25NYXJrZXJDbGljayBpcyByZXNwb25zaWJsZSBmb3IgZGV0ZXJtaW5nIHRoZSBvdXRwdXQgb2Ygd2hhdCBoYXBwZW5zIHdoZW4geW91IGNsaWNrIHRoZSBtYXAgaWNvbiBvbiB0aGUgbWFwLiBDYWxsZWQgYWJvdmUgd2l0aGluIHRoZSBhZGRNYXJrZXIgbWV0aG9kLCBiZWxvdyBkZWZpbmVzIGl0XG4gLy9vbk1hcmtlckNsaWNrIHRha2VzIHRoZSBwYXJhbWV0ZXJzIGxvY2F0aW9uLCBhbmQgaW5kZXguIFxuICAgIG9uTWFya2VyQ2xpY2sobG9jYXRpb24sIGluZGV4KSB7XG5cbiAgICAgICAvL3NldCB1cCBhIGNvbnN0YW50IHRoYXQgZXF1YWxzIHRoZSBsb2NhdGlvbi4gQmFzaWNhbGx5IHlvdSBhcmUgZmV0Y2hpbmcgZnJvbSB0aGUgbG9jYXRpb24gZGF0YSB0aGUgbmFtZSwgdHlwZSwgaW1hZ2UsIHN0YXRzLCBkZXNjcmlwdGlvbiwgc3BlY2llcywgY2xhc3NlcywgYW5kIGZhY3Rpb24obm90IGltcGxlbWVudGVkKSBmcm9tIHRoZSBkYXRhXG4gICAgICAgIGNvbnN0IHsgTmFtZSwgdHlwZSwgaW1hZ2UsIHN0YXRzLCBkZXNjcmlwdGlvbiwgc3BlY2llcywgY2xhc3NlcywgZmFjdGlvbiB9ID0gbG9jYXRpb247XG4gICAgICAgIC8vZGV0YWlsc1RhYiBpcyBlcXVhbCB0byB0aGUgZGV0YWlscyB0YWIgSUQgZnJvbSB0aGUgaHRtbC4gSXQgYXBwZW5kcyB0aGUgZGF0YSB0byB0aGUgZGV0YWlscy10YWIgaHRtbCBpbiBhIHRlbXBsYXRlIGxpdGVyYWwuXG4gICAgICAgIGNvbnN0IGRldGFpbHNUYWIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV0YWlscy10YWInKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyB0aGUgY2xhc3NlcyBkYXRhLCB0aGlzIHdhcyBkb25lIHRvIHRlc3QgdGhlIGNoYXJ0IGRhdGEgbGF0ZXIgZGVmaW5lZCBiZWxvdy4gXG4gICAgICAgIGNvbnNvbGUubG9nKCdDbGFzc2VzOicsIGNsYXNzZXMpO1xuICAgICAgICAvL3dpdGhpbiB0aGUgZGV0YWlsc1RhYi5pbm5lckhUTUwgeW91IGFyZSBzZXR0aW5nIHRoZSBkZXRhaWxzIHRhYiBpbmZvcm1hdGlvbiBhbmQgaXRzIGxvb2ssIGZlbHQgZXZlbiB3aXRoIHN0eWxlcyBpdCB3YXMgZWFzaWVyIHRvIGltcGxlbW50IGluIGEgdGVtcGxhdGUgbGl0ZXJhbC4gZWFjaCBsaW5lIG9mIHRoZSBodG1sXG4gICAgICAgIC8vY2FycmllcyB3aXRoIGl0IHRoZSBkYXRhIHR5cGUgZnJvbSB0aGUgbG9jYXRpb25zLmpzb24gcmVsYXRpdmUgdG8gdGhlIG1hcCBsb2NhdGlvbi4gXG4gICAgICAgIGRldGFpbHNUYWIuaW5uZXJIVE1MID0gYFxuICAgICAgICAgICAgPGgyIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojMDAwMDAwODA7IG1hcmdpbi1ib3R0b206IDFweFwiPiR7TmFtZX08L2gyPlxuICAgICAgICAgICAgPGltZyBzcmM9XCIke2ltYWdlfVwiIGFsdD1cIiR7TmFtZX1cIj5cbiAgICAgICAgICAgIDxwIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojMDAwMDAwODA7IGJvcmRlci1yYWRpdXM6IDVweDtcIj5EZXNjcmlwdGlvbjogJHtkZXNjcmlwdGlvbn08L3A+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkZXRhaWxzLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IzAwMDAwMDgwOyBib3JkZXItcmFkaXVzOiA1cHg7XCI+VHlwZTogJHt0eXBlfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgPHAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiMwMDAwMDA4MDsgYm9yZGVyLXJhZGl1czogNXB4O1wiPlBvcHVsYXRpb246ICR7c3RhdHMucG9wdWxhdGlvbn08L3A+XG4gICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojMDAwMDAwODA7IGJvcmRlci1yYWRpdXM6IDVweDtcIj5taWxpdGFyeTogJHtzdGF0cy5taWxpdGFyeX08L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRldGFpbHMtY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojMDAwMDAwODA7IGJvcmRlci1yYWRpdXM6IDVweDtcIj5NYWdpYzogJHtzdGF0cy5tYWdpY308L3A+XG4gICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjojMDAwMDAwODA7IGJvcmRlci1yYWRpdXM6IDVweDtcIj5XZWFsdGg6ICR7c3RhdHMubW9uZXl9PC9wPlxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IzAwMDAwMDgwOyBib3JkZXItcmFkaXVzOiA1cHg7XCI+UmVzb3VyY2U6ICR7c3RhdHMucmVzb3VyY2V9PC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkZXRhaWxzLWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IzAwMDAwMDgwOyBib3JkZXItcmFkaXVzOiA1cHg7XCI+R292ZXJuOiAke3N0YXRzLmdvdmVybmFuY2V9PC9wPlxuICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IzAwMDAwMDgwOyBib3JkZXItcmFkaXVzOiA1cHg7XCI+VGVjaDogJHtzdGF0cy50ZWNofTwvcD5cbiAgICAgICAgICAgICAgICAgICAgPHAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiMwMDAwMDA4MDsgYm9yZGVyLXJhZGl1czogNXB4O1wiPlBlYWNlOiAke3N0YXRzLnBlYWNlTGV2ZWx9PC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8aDI+U3RhdGlzdGljczwvaDI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG9udXQtc2V0dGluZ3NcIj4gIDxjYW52YXMgaWQ9XCJkb251dC1jaGFydC0ke2luZGV4fVwiPiA8L2NhbnZhcz48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJjbGFzc2VzLXRhYlwiIGNsYXNzPVwiY2xhc3Nlcy1zZXR0aW5nc1wiPiA8Y2FudmFzIGlkPVwiY2xhc3Nlcy1jaGFydC0ke2luZGV4fVwiPjwvY2FudmFzPjwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgIGA7XG4gICAgICAgIC8vYWJvdmUgdGhlIHRlbXBsYXRlIGxpdGVyYWwgd2lsbCBhbHNvIHNldHVwIHRoZSBjaGFydGpzIGxvY2F0aW9uIGFuZCB3aGF0IHByb3BlcnR5IHRvIHBhc3MuIEluIHRoaXMgY2FzZSBpdCBpcyBlaXRoZXIgZG9udXQtY2hhcnQgYW5kIHRoZSByZWxhdGl2ZSBpbmRleCwgb3IgY2xhc3Nlcy1jaGFydCBhbmQgaXRzIHJlbGF0aXZlIGluZGV4LlxuICAgICAgICBcbiAgICAgICAgLy8gYmVsb3cgaXMgdXNlZCB0byBzZXQgdXAgdGhlIGNoYXJ0LmpzIGludGl0aWFsaXphdGlvbiwgaWYgc3BlY2llcyBpcyB0cnVlIHRoZW4gc2V0IGEgdGltZW91dCB0aGF0IHdpbGwgY2FsbCB0aGUgY3JlYXRlRG9udXRDaGF0IHdpdGggaXRzIHBhcmFtZXRlcnMgc3BlY2llcyBhbmQgcmVsYXRpdmUgaW5kZXguIFxuICAgICAgICAvL2luIHRoZSBmaXJzdCBleGFtcGxlLCBJIHdhbnRlZCB0byBzZXQgdXAgYSB0aW1lIHNlcXVlbmNlIGp1c3QgdG8gZXhwZXJpbWVudCwgaW4gYWxsIHJlYWxpdHkgdGhlIHRpbWVvdXQgaXMgbm90IHJlYWxseSBuZWNjYXNhcnkuIFxuICAgICAgICBpZiAoc3BlY2llcykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEb251dENoYXJ0KHNwZWNpZXMsIGluZGV4KTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiBzdGF0ZW1lbnQgdGhhdCBzdGF0ZXMgdGhhdCBpZiBjbGFzc2VzIGlzIHRydWUgdGhlbiByZW5kZXIgdGhlIGNyZWF0ZUNsYXNzZXNDaGFydCB3aXRoIGNsYXNzZXMgYW5kIHJlbGF0aXZlIGluZGV4IHBhc3NlZCBhcyBpdHMgcGFyYW1ldGVycy4gXG4gICAgICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNsYXNzZXNDaGFydChjbGFzc2VzLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2JlbG93IHdhcyB1c2VkIHRvIGluaXRpYWxseSBzZXQgdXAgYSB0aGlyZCBjaGFydC4gSG93ZXZlciB3YXMgbm90IGFibGUgdG8gZ2V0IHRoZSBsaW5lcyB0byBzaG93IHVwIG9uIGl0IGZvciB3aGF0ZXZlciByZWFzb24sIGFuZCByYW4gb3V0IG9mIHRpbWUuIFxuXG4gICAgICAgIC8vIGlmIChmYWN0aW9uKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmNyZWF0ZUZhY3Rpb24oZmFjdGlvbiwgaW5kZXgpO1xuICAgICAgICAvLyB9XG4gICAgXG4gICAgICAgIC8vZW5zdXJpbmcgdGhhdCB0aGUgZGV0YWlsc1RhYiBzdHlsZSBpcyBzZXQgdG8gZmxleCBmb3IgZGVzaWduIHB1cnBvc2VzLiBcbiAgICAgICAgZGV0YWlsc1RhYi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIH1cblxuICAgIC8vYmVsb3cgaXMgdXNlZCB0byBzZXR1cCB0aGUgbG9naWMgYmVoaW5kIHRoZSBjdXN0b21JY29uIHdpdGggaXRzIHR5cGUgYXMgYSBwYXJhbWV0ZXIsIFxuXG4gICAgY3VzdG9tSWNvbih0eXBlKSB7XG4gICAgICAgIC8vZGVmaW5lIGljb25VcmwgXG4gICAgICAgIC8vZGVmaW5lIGljb25TaXplIHdoaWNoIGlzIGVxdWFsIHRvIDY0LCA2NC4gXG4gICAgICAgIC8vdGhpcyBpcyByZWxhdGl2ZSB0byBsZWFmbGV0LmpzJ3MgZG9jdW1lbnRhdGlvbiBvbiBjb250cm9saW5nIHRoZSBpY29uJ3MgXG4gICAgICAgIGxldCBpY29uVXJsO1xuICAgICAgICBsZXQgaWNvblNpemUgPSBbNjQsIDY0XTtcblxuXG4gICAgICAgIC8vIGEgc3dpdGNoIHN0YXRlbWVudCB0aGF0IGRlZmluZXMgdGhlIGxvY2F0aW9uIHR5cGUgYW5kIGl0cyByZWxhdGl2ZSBpbWFnZSBwZXIgdHlwZSBmb3VuZCBpbiB0aGUgbG9jYXRpb25zLmpzb25cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjaXR5JzpcbiAgICAgICAgICAgICAgICBpY29uVXJsID0gJ2Fzc2V0cy9jaXR5LWljb24ucG5nJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JyaWRnZSc6XG4gICAgICAgICAgICAgICAgaWNvblVybCA9ICdhc3NldHMvYnJpZGdlLWljb24ucG5nJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSAnZm9yZXN0JzpcbiAgICAgICAgICAgICAgICBpY29uVXJsID0gJ2Fzc2V0cy9mb3Jlc3QtaWNvbi5wbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdydWlucyc6XG4gICAgICAgICAgICAgICAgaWNvblVybCA9ICdhc3NldHMvcnVpbnMtaWNvbi5wbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbWluZSc6XG4gICAgICAgICAgICAgICAgaWNvblVybCA9ICdhc3NldHMvbWluZS1pY29uLnBuZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NhY3JlZHNpdGUnOlxuICAgICAgICAgICAgICAgIGljb25VcmwgPSAnYXNzZXRzL3NhY3JlZHNpdGUtaWNvbi5wbmcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdhbmNpZW50QmF0dGxlJzpcbiAgICAgICAgICAgICAgICBpY29uVXJsID0gJ2Fzc2V0cy9hbmNpZW50QmF0dGxlLWljb24ucG5nJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3dhbXAnOlxuICAgICAgICAgICAgICAgIGljb25VcmwgPSAnYXNzZXRzL3N3YW1wLWljb24ucG5nJztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpY29uVXJsID0gJ2Fzc2V0cy9ydWlucy1pY29uLnBuZyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvL2FzIHBlciBsZWFmbGV0cyBkb2N1bWVudGF0aW9uLCB5b3Ugd2FudCB0byByZXR1cm4gdGhlIExlYWZsZXQgaWNvbiB3aXRoIGl0cyBpY29uVXJsLCBpY29uU2l6ZSwgaWNvbkFuY2hvciwgaXRzIHBvcHVwQW5jaG9yLCBhbmQgaXRzIHR5cGU6IHR5cGUuIFxuICAgICAgICAvL0JJRyBOT1RFOiB3aGVuIGF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgaWNvbiBmaWx0ZXIgd2hlcmUgeW91IGNsaWNrIHRoZSBpY29uIGltYWdlIGF0IHRoZSBib3R0b20gdGFiIGFuZCBpdCB0b2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBhY3R1YWwgbWFwIGljb24uIEkgdW5kZXJzdG9vZCB0aGUgbG9naWMsIGhvd2V2ZXIsIFxuICAgICAgICAvL2NvdWxkIG5vdCB0aWUgaXQgdG8gbGVhZmxldCdzIHdheSBvZiBoYW5kbGluZyBpY29ucy4gSSBzdHJ1Z2dsZWQgZm9yIGFyb3VuZCBzaXggaG91cnMgYXR0ZW1wdGluZyB0byBmaWd1cmUgb3V0IHdoeSB0b2dnbGVMb2NhdGlvblZpc2liaWxpdHkodHlwZSkgZGVmaW5lZCBiZWxvdyB3YXMgbm90IHdvcmtpbmcuIEFzIEkgd2FzIFxuICAgICAgICAvL2NvcnJlY3RseSBwYXNzaW5nIHRoZSB0eXBlIHBhcmFtZXRlciB0byB0aGUgdG9nZ2xlTG9jYXRpb25WSXNpYmlsaXR5LiBIb3dldmVyIGFmdGVyIGhvdXJzIG9mIGRlYnVnZ2luZyBJIGZvdW5kIHRoYXQgd2l0aGluIHRoZSBMLmljb24sIGl0IGhhZCB0byBkZWZpbmUgdHlwZTogdHlwZSwgb3RoZXJ3aXNlIHRoZSBkYXRhIGp1c3RcbiAgICAgICAgLy93YXMgbm90IGNvbm5lY3RpbmcgdG8gdGhlIGxlYWZsZXQgY3VzdG9taXphdGlvbiBmb3IgdGhlIGljb24uIFxuICAgICAgICByZXR1cm4gTC5pY29uKHtcbiAgICAgICAgICAgIGljb25VcmwsXG4gICAgICAgICAgICBpY29uU2l6ZSxcbiAgICAgICAgICAgIGljb25BbmNob3I6IFtpY29uU2l6ZVswXSAvIDIsIGljb25TaXplWzFdIC8gMl0sXG4gICAgICAgICAgICBwb3B1cEFuY2hvcjogWzAsIC1pY29uU2l6ZVsxXSAvIDJdLFxuICAgICAgICAgICAgLy90eXBlOiB0eXBlLiB0aGlzIHNpbXBsZSBrZXkgdmFsdWUgcGFpciwgY3Vhc2VkIG1lIGhvdXJzIG9mIGRlYnVnZ2luZyBhbmQgZnJ1c3RyYXRpb24sIGJ1dCBldmVudHVhbGx5IGZvdW5kIHRoYXQgdHlwZTogdHlwZSBoYWQgYmUgZGVmaW5lZCBpbiBvcmRlciBmb3IgdGhlIHR5cGUgcGFyYW1ldGVyIGZyb20gdGhlIGljb24gdG8gY29ycmVjdGx5IHBhc3NcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICB9XG5cblxuXG4gICAgXG5cblxuICAgIC8vdGhlIGNyZWF0ZURvbnV0Q2hhcnQgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoZSBjaGFydCByZWxhdGl2ZSB0byB0aGUgc3BlY2llcyBkYXRhIGZvdW5kIGluIGxvY2F0aW9ucy5qc29uLCBpdCB0YWtlcyBpdCBwYXJhbWV0ZXJzIHNwZWNpZXMsIGFuZCBpbmRleC4gXG4gICAgLy9tYWpvcml0eSBvZiB0aGUgc2V0dXAgZm9yIHRoZSBjaGFydHMgSSB3YXMgYWJsZSB0byBpbXBsZW1lbnQgYnkgc2ltcGx5IGxvb2tpbmcgb3ZlciBwcm9qZWN0IDYncyBldmVudCBhcHBsaWNhdGlvbiBhcyB0aGUgd2F5IHRoZSBjaGFydHMgcnVuIGFyZSBzaW1pbGlhci5cbiAgICBjcmVhdGVEb251dENoYXJ0KHNwZWNpZXMsIGluZGV4LCkge1xuICAgICAgICAvL2NhbnZhc0lEIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBgZG9udXQtY2hhcnQtJyBmb3VuZCBpbiB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBodG1sLCBIb3dldmVyIHdoYXQgaXMgZXh0cmVtZWxseSBpbXBvcnRhbnQgaXMgcGFzc2luZyB0aGUgaW5kZXggdG8gdGhlIHRlbXBsYXRlIGxpdGVyYWwgYXMgYGRvbnV0LWNoYXJ0LSR7aW5kZXh9YFxuICAgICAgICAvLyB0aGUgaW5kZXggcGxhY2VkIGFmdGVyIHRoZSBodG1sIHRhZyBtZWFucyB0aGF0IHRoZSBodG1sIG9mIGRvbnV0LWNoYXJ0LSBpcyBub3cgcmVsYXRpdmUgdG8gdGhlIHNwZWNpZXMgaW5kZXguIFxuICAgICAgICAvL2NhbnZhcyBpcyBqdXN0IGF0dGFjaGluZyBhIGdldEVsZW1lbnRCeUlkIHRvIHRoZSBDYW52YXNJRCBkZWZpbmVkLiBcbiAgICAgICAgY29uc3QgY2FudmFzSWQgPSBgZG9udXQtY2hhcnQtJHtpbmRleH1gO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCk7XG4gICAgICAgIFxuICAgICAgICAvL2Vzc2VudGlhbCBlcnJvciBoYW5kbGluZyBpZiBjYW52YXNJRCBpcyBub3QgZm91bmQgLSBieSBkZWZhdWx0IGl0IHdpbGwgbG9nIGFuIGVyb3IgYmVjdWFzZSBpdCBvbmx5IHJldHVybnMgdGhlIGlkIG9uY2UgeW91IGNsaWNrIG9uIHRoZSBzcGVjaWZpYyBtYXAgbG9jYXRpb25cbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBDYW52YXMgbm90IGZvdW5kIGZvciBJRDogJHtjYW52YXNJZH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgQ2hhcnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDaGFydC5qcyBpcyBub3QgbG9hZGVkIG9yIGluaXRpYWxpemVkLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzcGVjaWVzIHx8IE9iamVjdC5rZXlzKHNwZWNpZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignU3BlY2llcyBkYXRhIGlzIGVtcHR5IG9yIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIENoYXJ0LmRlZmF1bHRzLmdsb2JhbC5hbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLy9zcGVjaWVzTmFtZXMgYW5kIHNwZWNpZXNWYWx1ZXMgYXJlIGltcG9ydGFudCB0byBiZSB0aWVkIHRvIHRoZSBPYmplY3Qua2V5cyBhbmQgb2JqZWN0LnZhbHVlcy4gdGhpcyBpcyBpbXBvcnRhbnQgYmVjdWFzZSBmb3IgZGlzcGxheWluZyB0aGUgY29ycmVjdCBncmFwaCBrZXkgdmFsdWUgcGFpcnMsIHRoZXNlIG11c3QgYmVcbiAgICAgICAgLy9kZWZpbmVkIGFzIGtleSB2YWx1ZSBwYWlycyByZW5kZXJlZCBhcyBvYmplY3RzLiBcbiAgICAgICAgY29uc3Qgc3BlY2llc05hbWVzID0gT2JqZWN0LmtleXMoc3BlY2llcyk7XG4gICAgICAgIGNvbnN0IHNwZWNpZXNWYWx1ZXMgPSBPYmplY3QudmFsdWVzKHNwZWNpZXMpO1xuXG4gICAgICAgIC8vdGhpcyBpcyBkaXJlY3RseSByZXNwb25zaWJsZSBmb3IgdGhlIHZpc3VhbCBkaXNwbGF5IG9mIHRoZSBzcGVjaWVzICdkb3VnaG51dCBjaGFydCdcbiAgICAgICAgbmV3IENoYXJ0KGN0eCwge1xuICAgICAgICAgICAgdHlwZTogJ2RvdWdobnV0JyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHNwZWNpZXNOYW1lcyxcbiAgICAgICAgICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogc3BlY2llc1ZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbJyNGRjYzODQnLCAnIzM2QTJFQicsICcjRkZDRTU2JywgJyM0QkMwQzAnLCAnIzk5NjZGRiddLFxuICAgICAgICAgICAgICAgICAgICBob3ZlckJhY2tncm91bmRDb2xvcjogWycjRkY2Mzg0JywgJyMzNkEyRUInLCAnI0ZGQ0U1NicsICcjNEJDMEMwJywgJyM5OTY2RkYnXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3V0b3V0UGVyY2VudGFnZTogNTAsXG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1NwZWNpZXMgRGVtb2dyYXBocycsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogJ3doaXRlJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgaXMgaW4gY2hhcmdlIG9mIGRpc3BsYXlpbmcgdGhlIHZhbHVlcyBpbiB0aGUgdG9vbHRpcCwgZXNzZW50aWFsbHkgbWFraW5nIHRoZSB0b29sdGlwIHNob3cgdGhlIGRhdGFzZXQsIGl0cyB0b3RhbCwgdGhlIGN1cnJlbnRWYWx1ZSBvZiB0aGUgZGF0YXNldCwgYW5kIGJhc2ljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBlbmRpbmcgYSBwZXJjZW50YWdlIGFmdGVyIGVhY2ggdmFsdWUuIFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICh0b29sdGlwSXRlbSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBkYXRhc2V0LmRhdGEucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRhdGFzZXQuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE1hdGguZmxvb3IoKChjdXJyZW50VmFsdWUgLyB0b3RhbCkgKiAxMDApICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW0uaW5kZXhdfTogJHtwZXJjZW50YWdlfSVgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250Q29sb3I6ICd3aGl0ZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy92ZXJ5IHNpbWlsaWFyIHRvIGFib3ZlLCBpbiBmYWN0IGVzc2VudGlhbGx5IHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkuIFRoZSBjcmVhdGVDbGFzc2VzQ2hhcnQgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IHVwIHRoZSBjaGFydCBmb3IgdGhlIHNlY29uZCBncmFwaCwgd2hlcmUgY2xhc3NlcyBhbmQgaXRzIGluZGV4IGFyZSBkaXNwbGF5ZWQuXG5cbiAgICBjcmVhdGVDbGFzc2VzQ2hhcnQoY2xhc3NlcywgaW5kZXgpIHtcbiAgICAgICAgLy90aGlzIHZlcnkga2V5IHBhcnQgaXMgc2hvd24gYWdhaW4sIHdoZXJlIGNhbnZhc0lkIGlzIGVxdWFsIHRvIGBjbGFzc2VzLWNoYXJ0LWAgdGhlbiBpdHMgcmVsYXRpdmUgaW5kZXggdG8gdGhlIGNsYXNzZXMgcGFyYW1ldGVyLiBcbiAgICAgICAgY29uc3QgY2FudmFzSWQgPSBgY2xhc3Nlcy1jaGFydC0ke2luZGV4fWA7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2lzaGVkIHRvIHNlZSBpZiB0aGUgaW5kZXggZm9yIGNsYXNzZXMgd2FzIHBhc3NlZCBjb3JyZWN0bHkuIC0gcGxhY2VkIGFzIGNvbW1lbnRzIGJlY3Vhc2UgaXQgd2lsbCBiZSBkZWZ1YWx0IHBhc3MgYSBub3QgZm91bmQgb3IgdW5kZWZpbmVkIHVudGlsIG1hcCBsb2NhdGlvbiBjbGlja2VkXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNhbnZhc0lkKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyhpbmRleClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NsYXNzZXM6JywgY2xhc3Nlcyk7XG4gICAgICAgIC8vZXJyb3IgaGFuZGxpbmcgaWYgY2xhc3NlcyBpbmRleCB3YXMgbm90IGZvdW5kLiBcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYENhbnZhcyBub3QgZm91bmQgZm9yIElEOiAke2NhbnZhc0lkfWApOyAtIGJ5IGRlZmF1bHQgd2lsbCB0aHJvdyBhIGVycm9yIGFzIHRoZSBtYXAgbG9jYXRpb24gaXMgbm90IGNsaWNrZWRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBDaGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NoYXJ0LmpzIGlzIG5vdCBsb2FkZWQgb3IgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCFjbGFzc2VzIHx8IE9iamVjdC5rZXlzKGNsYXNzZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2xhc3NlcyBkYXRhIGlzIGVtcHR5IG9yIHVuZGVmaW5lZC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBDaGFydC5kZWZhdWx0cy5nbG9iYWwuYW5pbWF0aW9uID0gZmFsc2U7XG4gICAgXG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyhjbGFzc2VzKTtcbiAgICAgICAgY29uc3QgY2xhc3NWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGNsYXNzZXMpO1xuICAgICAgICBjb25zb2xlLmxvZygnQ2xhc3NlczonLCBjbGFzc2VzKTtcbiAgICAgICAgXG4gICAgICAgIG5ldyBDaGFydChjdHgsIHtcbiAgICAgICAgICAgIHR5cGU6ICdiYXInLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGxhYmVsczogY2xhc3NOYW1lcyxcbiAgICAgICAgICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY2xhc3NWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogWycjRkY2Mzg0JywgJyMzNkEyRUInLCAnI0ZGQ0U1NicsICcjNEJDMEMwJywgJyM5OTY2RkYnXSxcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJCYWNrZ3JvdW5kQ29sb3I6IFsnI0ZGNjM4NCcsICcjMzZBMkVCJywgJyNGRkNFNTYnLCAnIzRCQzBDMCcsICcjOTk2NkZGJ11cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIGN1dG91dFBlcmNlbnRhZ2U6IDUwLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6ICdDbGFzc2VzIERlbW9ncmFwaHMnLFxuICAgICAgICAgICAgICAgICAgICBmb250Q29sb3I6ICd3aGl0ZSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICh0b29sdGlwSXRlbSwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhLmRhdGFzZXRzW3Rvb2x0aXBJdGVtLmRhdGFzZXRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG90YWwgPSBkYXRhc2V0LmRhdGEucmVkdWNlKChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUpID0+IHByZXZpb3VzVmFsdWUgKyBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGRhdGFzZXQuZGF0YVt0b29sdGlwSXRlbS5pbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IE1hdGguZmxvb3IoKChjdXJyZW50VmFsdWUgLyB0b3RhbCkgKiAxMDApICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZGF0YS5sYWJlbHNbdG9vbHRpcEl0ZW0uaW5kZXhdfTogJHtwZXJjZW50YWdlfSVgO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb250Q29sb3I6ICd3aGl0ZSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvL3RoZSBiZWxvdyBtZXRob2Qgd2FzIGNyZWF0ZWQgYW5kIG5lYXJseSBmaW5pc2hlZCBob3dldmVyIGNvdWxkbid0IGZpZ3VyZSBvdXQgdGhlIGlzc3VlIHdpdGggdGhlIGxpbmVzIG5vdCBzaG93aW5nIHVwIHdpdGhpbiB0aGUgYW1vdW50IG9mIHRpbWUgZ2l2ZW4uIFxuXG5cbiAgICAvLyAvLyBJbnNpZGUgY3JlYXRlRmFjdGlvbkNvbnRyb2xDaGFydCBtZXRob2RcblxuICAgIC8vIGNyZWF0ZUZhY3Rpb24oZmFjdGlvbiwgaW5kZXgpIHtcbiAgICAgICAgXG4gICAgLy8gICAgIGNvbnN0IGFyZWFMYWJlbHMgPSBPYmplY3Qua2V5cyhmYWN0aW9uKTtcbiAgICAvLyAgICAgY29uc3QgZmFjdGlvbkRhdGEgPSBPYmplY3QudmFsdWVzKGZhY3Rpb24pO1xuICAgIFxuICAgIC8vICAgICBjb25zdCBjYW52YXNJZCA9IGBmYWN0aW9uLWNoYXJ0LSR7aW5kZXh9YDtcbiAgICAvLyAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhgdGhpcyBpcyBjYW52YXNJRDogJHtjYW52YXNJZH1gKVxuICAgIC8vICAgICBjb25zb2xlLmxvZyhgdGhpcyBpcyBmYWN0aW9uOiAke2ZhY3Rpb259YClcbiAgICAvLyAgICAgY29uc29sZS5sb2coYHRoaXMgaXMgaW5kZXg6ICR7aW5kZXh9YClcbiAgICAvLyAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAvLyAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENhbnZhcyBub3QgZm91bmQgZm9yIElEOiAke2NhbnZhc0lkfWApO1xuICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgIC8vICAgICB9XG4gICAgXG4gICAgLy8gICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vICAgICBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgLy8gICAgICAgICB0eXBlOiAnbGluZScsXG4gICAgLy8gICAgICAgICBkYXRhOiB7XG4gICAgLy8gICAgICAgICAgICAgbGFiZWxzOiBhcmVhTGFiZWxzLFxuICAgIC8vICAgICAgICAgICAgIGRhdGFzZXRzOiBmYWN0aW9uRGF0YS5tYXAoKGZhY3Rpb24sIGkpID0+ICh7XG4gICAgLy8gICAgICAgICAgICAgICAgIGxhYmVsOiBgRmFjdGlvbiAke2kgKyAxfWAsXG4gICAgLy8gICAgICAgICAgICAgICAgIGRhdGE6IGZhY3Rpb24sXG4gICAgLy8gICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLFxuICAgIC8vICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogYHJnYmEoJHtNYXRoLnJhbmRvbSgpICogMjU1fSwgJHtNYXRoLnJhbmRvbSgpICogMjU1fSwgJHtNYXRoLnJhbmRvbSgpICogMjU1fSwgMSlgLFxuICAgIC8vICAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgIC8vICAgICAgICAgICAgIH0pKVxuICAgIC8vICAgICAgICAgfSxcbiAgICAvLyAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAvLyAgICAgICAgICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgIC8vICAgICAgICAgICAgIG1haW50YWluQXNwZWN0UmF0aW86IGZhbHNlLFxuICAgIC8vICAgICAgICAgICAgIHNjYWxlczoge1xuICAgIC8vICAgICAgICAgICAgICAgICB5QXhlczogW3sgdGlja3M6IHsgYmVnaW5BdFplcm86IHRydWUgfSB9XVxuICAgIC8vICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfSk7XG4gICAgLy8gfVxuXG4gICAgXG4gICAgLy9iZWxvdyBtZXRob2QgdG8gZGVmaW5lIHRoZSBhZGQgaWNvbiB0byB0aGUgYmVsb3cgbG9jYXRpb25zIHRhYi4gXG5cbiAgICBhZGRCcmlkZ2VJY29uVG9Mb2NhdGlvbnNUYWIoKSB7XG4gICAgICAgIC8vbG9jYXRpb25zVGFiIGlzIGVxdWFsIHRvIHRoZSBpZCBvZiBsb2NhdGlvbnMgdGFiLiBcbiAgICAgICAgY29uc3QgbG9jYXRpb25zVGFiID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvY2F0aW9ucy10YWInKTtcbiAgICAgICAgLy9sb2NhdGlvbnNUYWIgaW5uZXIgSFRITUwgaXMgc2V0IHRvIExvY2F0aW9ucy4gXG4gICAgICAgIGxvY2F0aW9uc1RhYi5pbm5lckhUTUw9YExvY2F0aW9uc2BcblxuICAgICAgICAvLyBHZXQgdW5pcXVlIGxvY2F0aW9uIHR5cGVzIC0geW91IHdhbnQgdG8gc2V0IHRoZSBzcHJlYWQgb2YgdGhlIG5ldyBTZXQgZGF0YSBhdCB0aGlzLmxvY2F0aW9ucyBtYXAgd2hlcmUgbG9jYXRpb24gd2lsbCByZXR1cm4gdGhlIGxvY2F0aW9uLnR5cGUuIFR5cGUgZm91bmQgb2YgY291cnNlIGluIHRoZSBsb2NhdGlvbnMuanNvbi5cbiAgICAgICAgY29uc3QgdW5pcXVlVHlwZXMgPSBbLi4ubmV3IFNldCh0aGlzLmxvY2F0aW9ucy5tYXAobG9jYXRpb24gPT4gbG9jYXRpb24udHlwZSkpXTtcbiAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGJ1dHRvbnMgZm9yIGVhY2ggdW5pcXVlIGxvY2F0aW9uIHR5cGUuIHRoaXMgd2lsbCByZW5kZXIgYSBidXR0b24gZm9yIGVhY2ggdW5pcXVlIGxvY2F0aW9uIHR5cGUgXG4gICAgICAgIHVuaXF1ZVR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAvL2J1dHRvbiBpcyBlcXVhbCB0byB0aGUgZG9jdW1lbnQuY3JlYXRlIGJ1dHRvblxuICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAvL3RoZSBidXR0b25zIHRleHQgY29udGVudCBpcyBlcXVhbCB0byB0aGUgdHlwZVxuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdHlwZTtcbiAgICAgICAgICAgIC8vYWRkIGxvY2F0aW9uIGJ1dHRvbiBjbGFzcyB0byB0aGUgYnV0dG9uXG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnbG9jYXRpb24tYnV0dG9uJyk7XG4gICAgICAgICAgICAvL3RoZW4gYWRkIGEgZXZlbnQgbGlzdGVuZXIgd2hpY2ggaXMgYSBjbGljayBldmVudCB3aGljaCB3aWxsIHJldHVybiB0aGUgdG9nZ2xlTE9jYXRpb25WSXNpYmlsaXR5IG1ldGhvZCB3aXRoIHR5cGUgYXMgaXRzIHBhcmFtZXRlci4gXG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnRvZ2dsZUxvY2F0aW9uVmlzaWJpbGl0eSh0eXBlKSk7XG4gICAgICAgICAgICAvL2F0IHRoZSBsb2NhdGlvbnNUYWIsIGFwcGVuZCBhIGNoaWxkIGVsZW1lbnQgd2l0aCBidXR0b24gYXMgaXRzIHBhcmFtZXRlciBcbiAgICAgICAgICAgIGxvY2F0aW9uc1RhYi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvL2JlbG93IGlzIHRoZSB0b2dnbGVMb2NhdGlvblZpc2liaWxpdHkgbWV0aG9kIHdpdGggdHlwZSBwYXNzZWQgYXMgaXRzIHBhcmFtZXRlciBcblxuICAgIHRvZ2dsZUxvY2F0aW9uVmlzaWJpbGl0eSh0eXBlKSB7XG4gICAgICAgIC8vZm9yIGVhY2ggbWFya2VycywgbWFya2VyIHdpbGwgcmV0dXJuIGEgc3RhdGVtZW50IHdpdGggY29uZGl0aW9uYWwgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMubWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbWFya2VyIG9wdGlvbnMsIG1hcmtlcm9wdGlvbnNpY29uIGFuZCBtYXJrZXIgb3B0aW9ucyBpY29uIG9wdGlvbnMgYXJlIGFsbCB0cnVlIHRoZW4gcmVuZGVyIHRoZSBsb2NhdGlvblRweWUgZXF1YWwgdG8gbWFya2VyLm9wdGlvbnMuaWNvbi5vcHRpb25zLnR5cGUuIFdoaWNoIGJ5IGRlZnVhbHQgd2lsbCBiZSB0cnVlLiBcbiAgICAgICAgICAgIGlmIChtYXJrZXIub3B0aW9ucyAmJiBtYXJrZXIub3B0aW9ucy5pY29uICYmIG1hcmtlci5vcHRpb25zLmljb24ub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uVHlwZSA9IG1hcmtlci5vcHRpb25zLmljb24ub3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgICAgIC8vIGlmIGxvY2F0aW9uVHlwZSBoYXMgYSB0eXBlIHJlbGF0aXZlIHRvIHRoZSB0eXBlIGZvdW5kIGluIHRoZSBsb2NhdGlvbiwgdGhlIG1hcCBhdCBoYXNMYXllciBmcm9tIGxlYWZsZXQgd2l0aCBpcyBtYXJrZXIgcGFyYW1ldGVyIHdpbGwgcmVtb3ZldGhlIGxlYWZsZXQgbGF5ZXIuIG1lYW5pbmcgcmVtb3ZlIHRoZSBsZWFmbGV0IGljb25cbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25UeXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1hcC5oYXNMYXllcihtYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5yZW1vdmVMYXllcihtYXJrZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuYWRkTGF5ZXIobWFya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vYmFzaWNhbGx5IGlmIHRoZSBsZWFmbGV0IGhhc0xheWVyIGlzIG5vdCB0cnVlIGFuZCB0aGUgYnV0dG9uIGlzIGNsaWNrZWQsIGl0IHdpbGwgdGhlbiBtYWtlIHRoZSBpY29uIGFwcGVhciwgaGFzTGF5ZXIobWFya2VyKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFwLmhhc0xheWVyKG1hcmtlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLmFkZExheWVyKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgbWFya2VyIGljb24gaXMgbm90IGRlZmluZWQgb3IgZm91bmQsIHRoZW4gYSBlcnJvciB3aWxsIGFwZWFyIHRvIHRoZSBjb25zb2xlLiBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTWFya2VyIGljb24gb3B0aW9ucyBhcmUgdW5kZWZpbmVkIG9yIGRvIG5vdCBleGlzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vL2NhbGwgdGhlIGNsYXNzIEZhbnRhc3lNYXAgd2l0aGluIGEgY29uc3RhbnQgY2FsbGVkIGZhbnRhc3lNYXBcbmNvbnN0IGZhbnRhc3lNYXAgPSBuZXcgRmFudGFzeU1hcCgpO1xuIl0sIm5hbWVzIjpbIl9yZWdlbmVyYXRvclJ1bnRpbWUiLCJlIiwidCIsInIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJuIiwiaGFzT3duUHJvcGVydHkiLCJvIiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImkiLCJTeW1ib2wiLCJhIiwiaXRlcmF0b3IiLCJjIiwiYXN5bmNJdGVyYXRvciIsInUiLCJ0b1N0cmluZ1RhZyIsImRlZmluZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIndyYXAiLCJHZW5lcmF0b3IiLCJjcmVhdGUiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwidHlwZSIsImFyZyIsImNhbGwiLCJoIiwibCIsImYiLCJzIiwieSIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJwIiwiZCIsImdldFByb3RvdHlwZU9mIiwidiIsInZhbHVlcyIsImciLCJkZWZpbmVJdGVyYXRvck1ldGhvZHMiLCJmb3JFYWNoIiwiX2ludm9rZSIsIkFzeW5jSXRlcmF0b3IiLCJpbnZva2UiLCJfdHlwZW9mIiwicmVzb2x2ZSIsIl9fYXdhaXQiLCJ0aGVuIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJFcnJvciIsImRvbmUiLCJtZXRob2QiLCJkZWxlZ2F0ZSIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsIlR5cGVFcnJvciIsInJlc3VsdE5hbWUiLCJuZXh0IiwibmV4dExvYyIsInB1c2hUcnlFbnRyeSIsInRyeUxvYyIsImNhdGNoTG9jIiwiZmluYWxseUxvYyIsImFmdGVyTG9jIiwidHJ5RW50cmllcyIsInB1c2giLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwiaXNOYU4iLCJsZW5ndGgiLCJkaXNwbGF5TmFtZSIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJtYXJrIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJhd3JhcCIsImFzeW5jIiwiUHJvbWlzZSIsImtleXMiLCJyZXZlcnNlIiwicG9wIiwicHJldiIsImNoYXJBdCIsInNsaWNlIiwic3RvcCIsInJ2YWwiLCJoYW5kbGUiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJnZW4iLCJyZWplY3QiLCJfbmV4dCIsIl90aHJvdyIsImtleSIsImluZm8iLCJlcnJvciIsIl9hc3luY1RvR2VuZXJhdG9yIiwiZm4iLCJzZWxmIiwiYXJncyIsImFyZ3VtZW50cyIsImFwcGx5IiwiZXJyIiwidW5kZWZpbmVkIiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJ0b1ByaW1pdGl2ZSIsIk51bWJlciIsIkZhbnRhc3lNYXAiLCJtYXAiLCJsb2NhdGlvbnMiLCJtYXJrZXJzIiwiYnJpZGdlTWFya2VyVmlzaWJsZSIsImluaXRpYWxpemVNYXAiLCJmZXRjaExvY2F0aW9uc0RhdGEiLCJjcmVhdGVEb251dENoYXJ0IiwiY3JlYXRlQ2xhc3Nlc0NoYXJ0IiwiX3RoaXMiLCJpbml0aWFsWm9vbSIsIkwiLCJyZW5kZXJlciIsImNhbnZhcyIsIm1pblpvb20iLCJtYXhab29tIiwic2V0VmlldyIsImltYWdlVXJsIiwiYm91bmRzIiwiaW1hZ2VPdmVybGF5IiwiYWRkVG8iLCJzZXRNYXhCb3VuZHMiLCJvcHRpb25zIiwibWF4Qm91bmRzVmlzY29zaXR5Iiwib24iLCJjdXJyZW50Wm9vbSIsImdldFpvb20iLCJzZXRab29tIiwiY29uc29sZSIsImxvZyIsImxhdGxuZyIsIl9mZXRjaExvY2F0aW9uc0RhdGEiLCJfY2FsbGVlIiwicmVzcG9uc2UiLCJkYXRhIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsImZldGNoIiwib2siLCJjb25jYXQiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwianNvbiIsImFkZE1hcmtlcnMiLCJhZGRCcmlkZ2VJY29uVG9Mb2NhdGlvbnNUYWIiLCJ0MCIsIl90aGlzMiIsImxvY2F0aW9uIiwiaW5kZXgiLCJYQ29vcmQiLCJZQ29vcmQiLCJtYXJrZXIiLCJpY29uIiwiY3VzdG9tSWNvbiIsIm9uTWFya2VyQ2xpY2siLCJfbGVhZmxldF9pZCIsIl90aGlzMyIsIk5hbWUiLCJpbWFnZSIsInN0YXRzIiwiZGVzY3JpcHRpb24iLCJzcGVjaWVzIiwiY2xhc3NlcyIsImZhY3Rpb24iLCJkZXRhaWxzVGFiIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsInBvcHVsYXRpb24iLCJtaWxpdGFyeSIsIm1hZ2ljIiwibW9uZXkiLCJyZXNvdXJjZSIsImdvdmVybmFuY2UiLCJ0ZWNoIiwicGVhY2VMZXZlbCIsInNldFRpbWVvdXQiLCJzdHlsZSIsImRpc3BsYXkiLCJpY29uVXJsIiwiaWNvblNpemUiLCJpY29uQW5jaG9yIiwicG9wdXBBbmNob3IiLCJjYW52YXNJZCIsImN0eCIsImdldENvbnRleHQiLCJDaGFydCIsImRlZmF1bHRzIiwiZ2xvYmFsIiwiYW5pbWF0aW9uIiwic3BlY2llc05hbWVzIiwic3BlY2llc1ZhbHVlcyIsImxhYmVscyIsImRhdGFzZXRzIiwiYmFja2dyb3VuZENvbG9yIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJyZXNwb25zaXZlIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsImN1dG91dFBlcmNlbnRhZ2UiLCJ0aXRsZSIsInRleHQiLCJmb250Q29sb3IiLCJ0b29sdGlwcyIsImVuYWJsZWQiLCJjYWxsYmFja3MiLCJsYWJlbCIsInRvb2x0aXBJdGVtIiwiZGF0YXNldCIsImRhdGFzZXRJbmRleCIsInRvdGFsIiwicmVkdWNlIiwicHJldmlvdXNWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsInBlcmNlbnRhZ2UiLCJNYXRoIiwiZmxvb3IiLCJsZWdlbmQiLCJsYXlvdXQiLCJwYWRkaW5nIiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwiY2xhc3NOYW1lcyIsImNsYXNzVmFsdWVzIiwiX3RoaXM0IiwibG9jYXRpb25zVGFiIiwidW5pcXVlVHlwZXMiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJTZXQiLCJidXR0b24iLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJhZGRFdmVudExpc3RlbmVyIiwidG9nZ2xlTG9jYXRpb25WaXNpYmlsaXR5IiwiYXBwZW5kQ2hpbGQiLCJfdGhpczUiLCJsb2NhdGlvblR5cGUiLCJoYXNMYXllciIsInJlbW92ZUxheWVyIiwiYWRkTGF5ZXIiLCJmYW50YXN5TWFwIl0sInNvdXJjZVJvb3QiOiIifQ==